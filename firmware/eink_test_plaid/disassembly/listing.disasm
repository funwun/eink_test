Disassembly Listing for einkdisplay
Generated From:
/home/david/microchip/harmony/projects/einkdisplay/firmware/einkdisplay.X/dist/default/production/einkdisplay.X.production.elf
Jan 30, 2016 1:41:08 PM

---  /home/david/microchip/harmony/v1_05/framework/system/ports/src/sys_ports.c  ------------------------
1:                   /*******************************************************************************
2:                     Ports System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_ports.c
9:                   
10:                    Summary:
11:                      Ports System Service interface implementation.
12:                  
13:                    Description:
14:                      The PORTS system service provides a simple interface to manage the PORTS
15:                      module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the PORTS system service. While building the system
17:                      service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Macro Definitions
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Included Files
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  #include "system_config.h"
57:                  #include "system/ports/sys_ports.h"
58:                  #include "peripheral/devcon/plib_devcon.h"
59:                  
60:                  
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  // Section: SYS PORTS File Scope Functions
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  
67:                  /******************************************************************************
68:                    Function:
69:                      PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
70:                  
71:                    Summary:
72:                      Reads the data from the I/O port.
73:                  
74:                    Description:
75:                      This function reads the data from the I/O port.
76:                  
77:                    Remarks:
78:                      None.
79:                  */
80:                  
81:                  PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
82:                  {
00000000  00000000   NOP
83:                      return PLIB_PORTS_Read( index, channel );
00000018  00000000   NOP
84:                  }
00000028  00000000   NOP
85:                  
86:                  
87:                  /******************************************************************************
88:                    Function:
89:                      void SYS_PORTS_Write( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
90:                                        		PORTS_DATA_TYPE value )
91:                  
92:                    Summary:
93:                      Writes the data from the I/O port.
94:                  
95:                    Description:
96:                      This function writes the data to the I/O port.
97:                  
98:                    Remarks:
99:                      None.
100:                 */
101:                 
102:                 void SYS_PORTS_Write( PORTS_MODULE_ID index,
103:                                       PORTS_CHANNEL channel,
104:                                       PORTS_DATA_TYPE value )
105:                 {
00000000  00000000   NOP
106:                     PLIB_PORTS_Write( index, channel, value );
0000001C  00000000   NOP
107:                 }
00000030  00000000   NOP
108:                 
109:                 
110:                 /******************************************************************************
111:                   Function:
112:                     void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
113:                 	                         PORTS_DATA_TYPE value,
114:                                          PORTS_DATA_MASK mask )
115:                 
116:                   Summary:
117:                     Sets the selected digital port/latch based on the mask.
118:                 
119:                   Description:
120:                     This function sets the selected digital port/latch relative to the mask.
121:                 
122:                   Remarks:
123:                     None.
124:                 */
125:                 
126:                 void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
127:                                     PORTS_DATA_TYPE value,
128:                                     PORTS_DATA_MASK mask )
129:                 {
00000000  00000000   NOP
130:                     PLIB_PORTS_Set( index, channel, value, mask );
00000024  00000000   NOP
131:                 }
00000040  00000000   NOP
132:                 
133:                 
134:                 /******************************************************************************
135:                   Function:
136:                     void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
137:                                            PORTS_DATA_MASK clearMask )
138:                 
139:                   Summary:
140:                     Clears the selected digital port.
141:                 
142:                   Description:
143:                     This function clears the selected digital port.
144:                 
145:                   Remarks:
146:                     None.
147:                 */
148:                 
149:                 void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
150:                                            PORTS_DATA_MASK clearMask )
151:                 {
00000000  00000000   NOP
152:                     PLIB_PORTS_Clear ( index, channel, clearMask );
00000020  00000000   NOP
153:                 }
00000038  00000000   NOP
154:                 
155:                 
156:                 /******************************************************************************
157:                   Function:
158:                     void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
159:                 								SYS_PORTS_PIN_DIRECTION pinDir,
160:                 								PORTS_CHANNEL channel,
161:                 								PORTS_DATA_MASK mask )
162:                   Summary:
163:                     Enables the direction for the selected port.
164:                 
165:                   Description:
166:                     This function enables the direction for the selected port.
167:                 
168:                   Remarks:
169:                     None.
170:                 */
171:                 
172:                 void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
173:                                              SYS_PORTS_PIN_DIRECTION pinDir,
174:                                              PORTS_CHANNEL channel,
175:                                              PORTS_DATA_MASK mask )
176:                 {
00000000  00000000   NOP
177:                     if (pinDir == SYS_PORTS_DIRECTION_INPUT)
00000024  00000000   NOP
178:                     {
179:                         PLIB_PORTS_DirectionInputSet(index, channel, mask);
00000034  00000000   NOP
180:                     }
181:                     else
182:                     {
183:                         PLIB_PORTS_DirectionOutputSet(index, channel, mask);
00000054  00000000   NOP
184:                     }
185:                 }
0000006C  00000000   NOP
186:                 
187:                 
188:                 /******************************************************************************
189:                   Function:
190:                     PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index,
191:                                                             PORTS_CHANNEL channel )
192:                 
193:                   Summary:
194:                     Reads the port direction for the selected port.
195:                 
196:                   Description:
197:                     This function reads the port direction for the selected port.
198:                 
199:                   Remarks:
200:                     None.
201:                 */
202:                 
203:                 PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
204:                 {
00000000  00000000   NOP
205:                     return PLIB_PORTS_DirectionGet( index, channel );
00000018  00000000   NOP
206:                 }
00000028  00000000   NOP
207:                 
208:                 
209:                 /******************************************************************************
210:                   Function:
211:                     void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
212:                                            PORTS_DATA_MASK toggleMask )
213:                 
214:                   Summary:
215:                     Toggles the selected digital port pins.
216:                 
217:                   Description:
218:                     This function toggles the selected digital port pins.
219:                 
220:                   Remarks:
221:                     None.
222:                 */
223:                 
224:                 void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
225:                                        PORTS_DATA_MASK toggleMask )
226:                 {
00000000  00000000   NOP
227:                     PLIB_PORTS_Toggle( index, channel, toggleMask );
00000020  00000000   NOP
228:                 }
00000038  00000000   NOP
229:                 
230:                 
231:                 /******************************************************************************
232:                   Function:
233:                     void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
234:                                                      PORTS_DATA_MASK mask )
235:                 
236:                   Summary:
237:                     Enables the open drain functionality for the selected port.
238:                 
239:                   Description:
240:                     This function enables the open drain functionality for the selected port.
241:                 
242:                   Remarks:
243:                     None.
244:                 */
245:                 
246:                 void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
247:                                                 PORTS_DATA_MASK mask )
248:                 {
00000000  00000000   NOP
249:                     PLIB_PORTS_OpenDrainEnable( index, channel, mask );
00000020  00000000   NOP
250:                 }
00000038  00000000   NOP
251:                 
252:                 
253:                 /******************************************************************************
254:                   Function:
255:                     void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
256:                                                      PORTS_DATA_MASK mask )
257:                 
258:                   Summary:
259:                     Disables the open drain functionality for the selected port.
260:                 
261:                   Description:
262:                     This function disables the open drain functionality for the selected port.
263:                 
264:                   Remarks:
265:                     None.
266:                 */
267:                 
268:                 void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
269:                                                  PORTS_DATA_MASK mask )
270:                 {
00000000  00000000   NOP
271:                     PLIB_PORTS_OpenDrainDisable( index, channel, mask );
00000020  00000000   NOP
272:                 }
00000038  00000000   NOP
273:                 
274:                 
275:                 // *****************************************************************************
276:                 // *****************************************************************************
277:                 // Section: SYS Change Notification Pins Routines
278:                 // *****************************************************************************
279:                 // *****************************************************************************
280:                 
281:                 /******************************************************************************
282:                   Function:
283:                     void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
284:                 
285:                   Summary:
286:                     Globally enables the change notification for the selected port.
287:                 
288:                   Description:
289:                     This function globally enables the change notification for the selected port.
290:                 
291:                   Remarks:
292:                     None.
293:                 */
294:                 
295:                 void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
296:                 {
00000000  00000000   NOP
297:                     PLIB_PORTS_ChangeNoticeEnable( index );
00000014  00000000   NOP
298:                 }
00000020  00000000   NOP
299:                 
300:                 
301:                 /******************************************************************************
302:                   Function:
303:                     void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
304:                 
305:                   Summary:
306:                     Globally disables the change notification for the selected port.
307:                 
308:                   Description:
309:                     This function globally disables the change notification for the selected port.
310:                 
311:                   Remarks:
312:                     None.
313:                 */
314:                 
315:                 void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
316:                 {
00000000  00000000   NOP
317:                     PLIB_PORTS_ChangeNoticeDisable( index );
00000014  00000000   NOP
318:                 }
00000020  00000000   NOP
319:                 
320:                 
321:                 /******************************************************************************
322:                   Function:
323:                     void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
324:                                                              PORTS_CHANGE_NOTICE_PIN pinNum,
325:                                                              SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
326:                 
327:                   Summary:
328:                     Enables the change notification for the selected port.
329:                 
330:                   Description:
331:                     This function enables the change notification for the selected port.
332:                 
333:                   Remarks:
334:                     None.
335:                 */
336:                 
337:                 void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
338:                                                          PORTS_CHANGE_NOTICE_PIN pinNum,
339:                                                          SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
340:                 {
00000000  00000000   NOP
341:                     switch(value)
0000001C  00000000   NOP
342:                     {
343:                         case SYS_PORTS_PULLUP_DISABLE:
344:                             PLIB_PORTS_ChangeNoticePullUpDisable(index, pinNum);
0000003C  00000000   NOP
345:                             break;
0000004C  00000000   NOP
346:                         case SYS_PORTS_PULLUP_ENABLE:
347:                             PLIB_PORTS_ChangeNoticePullUpEnable(index, pinNum);
00000054  00000000   NOP
348:                             break;
00000064  00000000   NOP
349:                     }
350:                     PLIB_PORTS_PinChangeNoticeEnable( index, pinNum );
00000068  00000000   NOP
351:                 }
00000078  00000000   NOP
352:                 
353:                 
354:                 /******************************************************************************
355:                   Function:
356:                     void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
357:                                                               PORTS_CHANGE_NOTICE_PIN pinNum )
358:                 
359:                   Summary:
360:                     Disables the change notification for the selected port.
361:                 
362:                   Description:
363:                     This function disables the change notification for the selected port.
364:                 
365:                   Remarks:
366:                     None.
367:                 */
368:                 
369:                 void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
370:                                                           PORTS_CHANGE_NOTICE_PIN pinNum )
371:                 {
00000000  00000000   NOP
372:                     PLIB_PORTS_PinChangeNoticeDisable( index, pinNum );
00000018  00000000   NOP
373:                 }
00000028  00000000   NOP
374:                 
375:                 
376:                 /******************************************************************************
377:                   Function:
378:                     void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
379:                 
380:                   Summary:
381:                     Enables the change notification for the selected port in Sleep or Idle mode.
382:                 
383:                   Description:
384:                     This function enables the change notification for the selected port in Sleep
385:                     or Idle mode.
386:                 
387:                   Remarks:
388:                     None.
389:                 */
390:                 
391:                 void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
392:                 {
00000000  00000000   NOP
393:                     PLIB_PORTS_ChangeNoticeInIdleEnable( index );
00000014  00000000   NOP
394:                 }
00000020  00000000   NOP
395:                 
396:                 
397:                 // *****************************************************************************
398:                 /* Function:
399:                     void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index)
400:                 
401:                   Summary:
402:                     Disables the change notification for the selected port in Sleep or Idle mode.
403:                 
404:                   Description:
405:                     This function disables the change notification for the selected port in Sleep
406:                     or Idle mode.
407:                 
408:                   Remarks:
409:                     None.
410:                 */
411:                 
412:                 void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index )
413:                 {
00000000  00000000   NOP
414:                     PLIB_PORTS_ChangeNoticeInIdleDisable( index );
00000014  00000000   NOP
415:                 }
00000020  00000000   NOP
416:                 
417:                 
418:                 // *****************************************************************************
419:                 /* Function:
420:                     void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
421:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
422:                 
423:                   Summary:
424:                     Enables weak pull-up on change notification pin.
425:                 
426:                   Description:
427:                     This function enables weak pull-up on change notification pin.
428:                 
429:                   Remarks:
430:                     None.
431:                 */
432:                 
433:                 void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
434:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
435:                 {
00000000  00000000   NOP
436:                     PLIB_PORTS_ChangeNoticePullUpEnable ( index, pinNum );
00000018  00000000   NOP
437:                 }
00000028  00000000   NOP
438:                 
439:                 
440:                 // *****************************************************************************
441:                 /* Function:
442:                     void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
443:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
444:                 
445:                   Summary:
446:                     Disables pull-up on input change.
447:                 
448:                   Description:
449:                     This function disables pull-up on input change.
450:                 
451:                   Remarks:
452:                     None.
453:                 */
454:                 
455:                 void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
456:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
457:                 {
00000000  00000000   NOP
458:                     PLIB_PORTS_ChangeNoticePullUpDisable ( index, pinNum );
00000018  00000000   NOP
459:                 }
00000028  00000000   NOP
460:                 
461:                 
462:                 // *****************************************************************************
463:                 // *****************************************************************************
464:                 // Section: SYS PORT PINS Control Routines
465:                 // *****************************************************************************
466:                 // *****************************************************************************
467:                 
468:                 // *****************************************************************************
469:                 /* Function:
470:                     void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
471:                     								PORTS_PIN_MODE mode)
472:                 
473:                   Summary:
474:                     Enables the selected pin as analog or digital.
475:                 
476:                   Description:
477:                     This function enables the selected pin as analog or digital.
478:                 
479:                  Remarks:
480:                     None.
481:                 */
482:                 
483:                 void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
484:                 								PORTS_PIN_MODE mode)
485:                 {
00000000  00000000   NOP
486:                     PLIB_PORTS_PinModeSelect ( index, pin, mode);
0000001C  00000000   NOP
487:                 }
00000030  00000000   NOP
488:                 
489:                 
490:                 // *****************************************************************************
491:                 /* Function:
492:                     void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
493:                                               PORTS_CHANNEL channel,
494:                                               PORTS_BIT_POS bitPos
495:                                               bool value )
496:                   Summary:
497:                     Writes the selected digital pin.
498:                 
499:                   Description:
500:                     This function writes the selected digital pin.
501:                 
502:                   Remarks:
503:                     None.
504:                 */
505:                 
506:                 void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
507:                                           PORTS_CHANNEL channel,
508:                                           PORTS_BIT_POS bitPos,
509:                                           bool value )
510:                 {
9D0020A0  27BDFFE8   ADDIU SP, SP, -24
9D0020A4  AFBF0014   SW RA, 20(SP)
9D0020A8  AFBE0010   SW S8, 16(SP)
9D0020AC  03A0F021   ADDU S8, SP, ZERO
9D0020B0  AFC40018   SW A0, 24(S8)
9D0020B4  AFC5001C   SW A1, 28(S8)
9D0020B8  AFC60020   SW A2, 32(S8)
9D0020BC  00E01021   ADDU V0, A3, ZERO
9D0020C0  A3C20024   SB V0, 36(S8)
511:                     PLIB_PORTS_PinWrite ( index, channel, bitPos, value );
9D0020C4  93C20024   LBU V0, 36(S8)
9D0020C8  8FC40018   LW A0, 24(S8)
9D0020CC  8FC5001C   LW A1, 28(S8)
9D0020D0  8FC60020   LW A2, 32(S8)
9D0020D4  00403821   ADDU A3, V0, ZERO
9D0020D8  0F40095A   JAL 0x9D002568
9D0020DC  00000000   NOP
512:                 }
9D0020E0  03C0E821   ADDU SP, S8, ZERO
9D0020E4  8FBF0014   LW RA, 20(SP)
9D0020E8  8FBE0010   LW S8, 16(SP)
9D0020EC  27BD0018   ADDIU SP, SP, 24
9D0020F0  03E00008   JR RA
9D0020F4  00000000   NOP
513:                 
514:                 
515:                 // *****************************************************************************
516:                 /* Function:
517:                     bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
518:                                              PORTS_CHANNEL channel,
519:                                              PORTS_BIT_POS bitPos )
520:                 
521:                   Summary:
522:                     Reads the selected digital pin.
523:                 
524:                   Description:
525:                     This function reads the selected digital pin.
526:                 
527:                   Remarks:
528:                     None.
529:                 */
530:                 
531:                 bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
532:                                          PORTS_CHANNEL channel,
533:                                          PORTS_BIT_POS bitPos )
534:                 {
9D0023B8  27BDFFE8   ADDIU SP, SP, -24
9D0023BC  AFBF0014   SW RA, 20(SP)
9D0023C0  AFBE0010   SW S8, 16(SP)
9D0023C4  03A0F021   ADDU S8, SP, ZERO
9D0023C8  AFC40018   SW A0, 24(S8)
9D0023CC  AFC5001C   SW A1, 28(S8)
9D0023D0  AFC60020   SW A2, 32(S8)
535:                     return PLIB_PORTS_PinGet ( index, channel, bitPos );
9D0023D4  8FC40018   LW A0, 24(S8)
9D0023D8  8FC5001C   LW A1, 28(S8)
9D0023DC  8FC60020   LW A2, 32(S8)
9D0023E0  0F400A57   JAL 0x9D00295C
9D0023E4  00000000   NOP
536:                 }
9D0023E8  03C0E821   ADDU SP, S8, ZERO
9D0023EC  8FBF0014   LW RA, 20(SP)
9D0023F0  8FBE0010   LW S8, 16(SP)
9D0023F4  27BD0018   ADDIU SP, SP, 24
9D0023F8  03E00008   JR RA
9D0023FC  00000000   NOP
537:                 
538:                 
539:                 // *****************************************************************************
540:                 /* Function:
541:                     void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
542:                                                PORTS_CHANNEL channel,
543:                                                PORTS_BIT_POS bitPos )
544:                 
545:                   Summary:
546:                     Toggles the selected digital pin.
547:                 
548:                   Description:
549:                     This function toggles the selected digital pin.
550:                 
551:                   Remarks:
552:                     None.
553:                 */
554:                 
555:                 void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
556:                                            PORTS_CHANNEL channel,
557:                                            PORTS_BIT_POS bitPos )
558:                 {
00000000  00000000   NOP
559:                     PLIB_PORTS_PinToggle ( index, channel, bitPos );
0000001C  00000000   NOP
560:                 }
00000030  00000000   NOP
561:                 
562:                 
563:                 // *****************************************************************************
564:                 /* Function:
565:                     void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
566:                                            PORTS_CHANNEL channel,
567:                                            PORTS_BIT_POS bitPos )
568:                 
569:                   Summary:
570:                     Sets the selected digital pin/latch.
571:                 
572:                   Description:
573:                     This function sets the selected digital pin/latch.
574:                 
575:                   Remarks:
576:                     None.
577:                 */
578:                 
579:                 void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
580:                                        PORTS_CHANNEL channel,
581:                                        PORTS_BIT_POS bitPos )
582:                 {
9D002400  27BDFFE8   ADDIU SP, SP, -24
9D002404  AFBF0014   SW RA, 20(SP)
9D002408  AFBE0010   SW S8, 16(SP)
9D00240C  03A0F021   ADDU S8, SP, ZERO
9D002410  AFC40018   SW A0, 24(S8)
9D002414  AFC5001C   SW A1, 28(S8)
9D002418  AFC60020   SW A2, 32(S8)
583:                     PLIB_PORTS_PinSet( index, channel, bitPos );
9D00241C  8FC40018   LW A0, 24(S8)
9D002420  8FC5001C   LW A1, 28(S8)
9D002424  8FC60020   LW A2, 32(S8)
9D002428  0F400B36   JAL 0x9D002CD8
9D00242C  00000000   NOP
584:                 }
9D002430  03C0E821   ADDU SP, S8, ZERO
9D002434  8FBF0014   LW RA, 20(SP)
9D002438  8FBE0010   LW S8, 16(SP)
9D00243C  27BD0018   ADDIU SP, SP, 24
9D002440  03E00008   JR RA
9D002444  00000000   NOP
585:                 
586:                 
587:                 // *****************************************************************************
588:                 /* Function:
589:                     void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
590:                                               PORTS_CHANNEL channel,
591:                                               PORTS_BIT_POS bitPos )
592:                 
593:                   Summary:
594:                     Clears the selected digital pin.
595:                 
596:                   Description:
597:                     This function clears the selected digital pin.
598:                 
599:                   Remarks:
600:                     None.
601:                 */
602:                 
603:                 void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
604:                                           PORTS_CHANNEL channel,
605:                                           PORTS_BIT_POS bitPos )
606:                 {
9D002448  27BDFFE8   ADDIU SP, SP, -24
9D00244C  AFBF0014   SW RA, 20(SP)
9D002450  AFBE0010   SW S8, 16(SP)
9D002454  03A0F021   ADDU S8, SP, ZERO
9D002458  AFC40018   SW A0, 24(S8)
9D00245C  AFC5001C   SW A1, 28(S8)
9D002460  AFC60020   SW A2, 32(S8)
607:                     PLIB_PORTS_PinClear ( index, channel, bitPos );
9D002464  8FC40018   LW A0, 24(S8)
9D002468  8FC5001C   LW A1, 28(S8)
9D00246C  8FC60020   LW A2, 32(S8)
9D002470  0F400B41   JAL 0x9D002D04
9D002474  00000000   NOP
608:                 }
9D002478  03C0E821   ADDU SP, S8, ZERO
9D00247C  8FBF0014   LW RA, 20(SP)
9D002480  8FBE0010   LW S8, 16(SP)
9D002484  27BD0018   ADDIU SP, SP, 24
9D002488  03E00008   JR RA
9D00248C  00000000   NOP
609:                 
610:                 
611:                 // *****************************************************************************
612:                 /* Function:
613:                     void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
614:                                                      SYS_PORTS_PIN_DIRECTION pinDir,
615:                                                      PORTS_CHANNEL channel,
616:                                                      PORTS_BIT_POS bitPos )
617:                   Summary:
618:                     Enables the direction for the selected pin.
619:                 
620:                   Description:
621:                     This function enables the direction for the selected pin.
622:                 
623:                   Remarks:
624:                     None.
625:                 */
626:                 
627:                 void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
628:                                                  SYS_PORTS_PIN_DIRECTION pinDir,
629:                                                  PORTS_CHANNEL channel,
630:                                                  PORTS_BIT_POS bitPos )
631:                 {
9D001B90  27BDFFE8   ADDIU SP, SP, -24
9D001B94  AFBF0014   SW RA, 20(SP)
9D001B98  AFBE0010   SW S8, 16(SP)
9D001B9C  03A0F021   ADDU S8, SP, ZERO
9D001BA0  AFC40018   SW A0, 24(S8)
9D001BA4  AFC5001C   SW A1, 28(S8)
9D001BA8  AFC60020   SW A2, 32(S8)
9D001BAC  AFC70024   SW A3, 36(S8)
632:                     if (pinDir == SYS_PORTS_DIRECTION_OUTPUT)
9D001BB0  8FC2001C   LW V0, 28(S8)
9D001BB4  14400008   BNE V0, ZERO, 0x9D001BD8
9D001BB8  00000000   NOP
633:                     {
634:                         PLIB_PORTS_PinDirectionOutputSet(index, channel, bitPos);
9D001BBC  8FC40018   LW A0, 24(S8)
9D001BC0  8FC50020   LW A1, 32(S8)
9D001BC4  8FC60024   LW A2, 36(S8)
9D001BC8  0F400B57   JAL 0x9D002D5C
9D001BCC  00000000   NOP
9D001BD0  0B4006FB   J 0x9D001BEC
9D001BD4  00000000   NOP
635:                     }
636:                     else
637:                     {
638:                         PLIB_PORTS_PinDirectionInputSet(index, channel, bitPos);
9D001BD8  8FC40018   LW A0, 24(S8)
9D001BDC  8FC50020   LW A1, 32(S8)
9D001BE0  8FC60024   LW A2, 36(S8)
9D001BE4  0F400B4C   JAL 0x9D002D30
9D001BE8  00000000   NOP
639:                     }
640:                 }
9D001BEC  03C0E821   ADDU SP, S8, ZERO
9D001BF0  8FBF0014   LW RA, 20(SP)
9D001BF4  8FBE0010   LW S8, 16(SP)
9D001BF8  27BD0018   ADDIU SP, SP, 24
9D001BFC  03E00008   JR RA
9D001C00  00000000   NOP
641:                 
642:                 
643:                 // *****************************************************************************
644:                 /* Function:
645:                     void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
646:                                                         PORTS_CHANNEL channel,
647:                                                         PORTS_BIT_POS bitPos )
648:                 
649:                   Summary:
650:                     Enables the open-drain functionality for the selected pin.
651:                 
652:                   Description:
653:                     This function enables the open-drain functionality for the selected pin.
654:                 
655:                   Remarks:
656:                     None.
657:                 */
658:                 
659:                 void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
660:                                                     PORTS_CHANNEL channel,
661:                                                     PORTS_BIT_POS bitPos )
662:                 {
00000000  00000000   NOP
663:                     PLIB_PORTS_PinOpenDrainEnable ( index, channel, bitPos );
0000001C  00000000   NOP
664:                 }
00000030  00000000   NOP
665:                 
666:                 
667:                 // *****************************************************************************
668:                 /* Function:
669:                     void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
670:                                                          PORTS_CHANNEL channel,
671:                                                          PORTS_BIT_POS bitPos )
672:                 
673:                   Summary:
674:                     Disables the open-drain functionality for the selected pin.
675:                 
676:                   Description:
677:                     This function disables the open-drain functionality for the selected pin.
678:                 
679:                   Remarks:
680:                     None.
681:                 */
682:                 
683:                 void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
684:                                                      PORTS_CHANNEL channel,
685:                                                      PORTS_BIT_POS bitPos )
686:                 {
00000000  00000000   NOP
687:                     PLIB_PORTS_PinOpenDrainDisable ( index, channel, bitPos );
0000001C  00000000   NOP
688:                 }
00000030  00000000   NOP
689:                 
690:                 
691:                 // *****************************************************************************
692:                 /* Function:
693:                     void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
694:                 							  PORTS_REMAP_INPUT_FUNCTION function,
695:                 							  PORTS_REMAP_INPUT_PIN      remapPin )
696:                 
697:                   Summary:
698:                     Input/Output (I/O) function remapping.
699:                 
700:                   Description:
701:                     This function controls the I/O function remapping.
702:                 
703:                   Precondition:
704:                     None.
705:                 */	
706:                 void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
707:                 						   PORTS_REMAP_INPUT_FUNCTION function,
708:                 						   PORTS_REMAP_INPUT_PIN      remapPin )
709:                 {
00000000  00000000   NOP
710:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
0000001C  00000000   NOP
711:                     PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
00000028  00000000   NOP
712:                 	PLIB_PORTS_RemapInput( index, function, remapPin);
00000038  00000000   NOP
713:                 }
0000004C  00000000   NOP
714:                 
715:                 // *****************************************************************************
716:                 /* Function:
717:                     void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
718:                                                       PORTS_REMAP_OUTPUT_FUNCTION function,
719:                                                       PORTS_REMAP_OUTPUT_PIN      remapPin )
720:                 
721:                   Summary:
722:                     Input/Output (I/O) function remapping.
723:                 
724:                   Description:
725:                     This function controls the I/O function remapping.
726:                 
727:                   Precondition:
728:                     None.
729:                 */
730:                 void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
731:                 						    PORTS_REMAP_OUTPUT_FUNCTION function,
732:                 						    PORTS_REMAP_OUTPUT_PIN      remapPin )
733:                 {
00000000  00000000   NOP
734:                 	PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
0000001C  00000000   NOP
735:                     PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
00000028  00000000   NOP
736:                     PLIB_PORTS_RemapOutput( index, function, remapPin);
00000038  00000000   NOP
737:                 }
0000004C  00000000   NOP
738:                 
739:                 /*******************************************************************************
740:                  End of File
741:                 */
742:                 
---  /home/david/microchip/harmony/v1_05/framework/system/int/src/sys_int_pic32.c  ----------------------
1:                   /*******************************************************************************
2:                     Interrupt System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_int_pic32.c
9:                   
10:                    Summary:
11:                      Interrupt System Service APIs.
12:                  
13:                    Description:
14:                      This file contains functions related to the Interrupt System Service for PIC32
15:                      devices.
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "system/int/sys_int.h"
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Function Definitions
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  
52:                  /******************************************************************************
53:                  
54:                    Function:
55:                      void SYS_INT_Initialize ( void )
56:                  
57:                    Summary:
58:                      Configures and initializes the interrupt sub-system.
59:                  
60:                    Description:
61:                      This function appropriately configures and initializes the interrupt sub-system
62:                      for the current system design.
63:                  
64:                    Precondition:
65:                      None.
66:                  
67:                    Parameters:
68:                      None.
69:                  
70:                    Returns:
71:                      None.
72:                  
73:                    Example:
74:                    <code>
75:                    SYS_INT_Initialize();
76:                    </code>
77:                  
78:                    Remarks:
79:                      This function is not implemented in the System Interrupt library.  It is
80:                      implemented by the board support package (using the processor-specific
81:                      interrupt peripheral library) because it requires knowledge of the specific
82:                      interrupt requirements for each system.
83:                  */
84:                  
85:                  void SYS_INT_Initialize ( void )
86:                  
87:                  {
9D0029C8  27BDFFE8   ADDIU SP, SP, -24
9D0029CC  AFBF0014   SW RA, 20(SP)
9D0029D0  AFBE0010   SW S8, 16(SP)
9D0029D4  03A0F021   ADDU S8, SP, ZERO
88:                      /* enable the multi vector */
89:                      PLIB_INT_MultiVectorSelect( INT_ID_0 );
9D0029D8  00002021   ADDU A0, ZERO, ZERO
9D0029DC  0F400BE5   JAL 0x9D002F94
9D0029E0  00000000   NOP
90:                  }
9D0029E4  03C0E821   ADDU SP, S8, ZERO
9D0029E8  8FBF0014   LW RA, 20(SP)
9D0029EC  8FBE0010   LW S8, 16(SP)
9D0029F0  27BD0018   ADDIU SP, SP, 24
9D0029F4  03E00008   JR RA
9D0029F8  00000000   NOP
91:                  
92:                  //*******************************************************************************
93:                  /*  Function:
94:                       SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
95:                  
96:                    Summary:
97:                      Disables interrupts to the processor and return the previois status.
98:                      
99:                    Description:
100:                     This function disables interrupts to the processor at the top level. This
101:                     function can be called to prevent any source from being able to generate an
102:                     interrupt. It returns the processor status (which includes global interrupt
103:                     status and Interrupt Priority status) before disabling the interrupts.
104:                 
105:                   Remarks:
106:                     See sys_int.h file for more details.
107:                 */
108:                 
109:                 SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
110:                 {
00000000  00000000   NOP
111:                     SYS_INT_PROCESSOR_STATUS processorStatus;
112:                 
113:                     /* Save the processor status and then Disable the global interrupt */
114:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
00000010  00000000   NOP
115:                 
116:                     /* return the processor status */
117:                     return processorStatus;
00000020  00000000   NOP
118:                 }
00000024  00000000   NOP
119:                 
120:                 //*******************************************************************************
121:                 /* Function:
122:                     void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
123:                 
124:                   Summary:
125:                     Restores the processor status.
126:                 
127:                   Description:
128:                     This function sets the processor status based on the 32 bit value passed as 
129:                     a parameter. 0th bit of the status is for Master Interrupt status.
130:                 
131:                   Remarks:
132:                     See sys_int.h file for more details.
133:                 */
134:                 
135:                 void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
136:                 {
00000000  00000000   NOP
137:                     PLIB_INT_SetState(INT_ID_0, processorStatus);
00000014  00000000   NOP
138:                 }
00000024  00000000   NOP
139:                 
140:                 // *****************************************************************************
141:                 /*  Disable the generation of interrupts to the CPU
142:                 
143:                   Summary:
144:                      Disables all interrupts
145:                 
146:                   Description:
147:                      This function disables all interrupts.
148:                 
149:                   Remarks:
150:                     This API will be depricated soon. Use "SYS_INT_StatusGetAndDisable" instead.
151:                  */
152:                 
153:                 bool SYS_INT_Disable( void )
154:                 {
00000000  00000000   NOP
155:                     SYS_INT_PROCESSOR_STATUS processorStatus;
156:                 
157:                     /* Save the processor status and then Disable the global interrupt */
158:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
00000010  00000000   NOP
159:                 
160:                     /* return the interrupt status */
161:                     return (bool)(processorStatus & 0x01);
00000020  00000000   NOP
162:                 }
00000030  00000000   NOP
163:                 
164:                 // *****************************************************************************
165:                 /* Function:
166:                     bool SYS_INT_SourceDisable ( INT_SOURCE source )
167:                 
168:                   Summary:
169:                     Disables the interrupt source.
170:                 
171:                   Description:
172:                     This routine disables the given source from generating interrupts the 
173:                     processor when events occur.It returns the interrupt source enable/disable 
174:                 	status before disabling the interrupt source.
175:                 
176:                   Remarks:
177:                     See sys_int.h file for more details.
178:                  */
179:                 
180:                 
181:                 bool SYS_INT_SourceDisable ( INT_SOURCE source )
182:                 {
00000000  00000000   NOP
183:                     bool intSrcStatus;
184:                     SYS_INT_PROCESSOR_STATUS processorStatus;
185:                 
186:                     /* Save the processor status and then Disable the global interrupt */
187:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
00000014  00000000   NOP
188:                     
189:                     /* get the interrupt status of this source before disable is called */
190:                     intSrcStatus = PLIB_INT_SourceIsEnabled (INT_ID_0 , source);
00000024  00000000   NOP
191:                 
192:                     /* disable the interrupts */
193:                     PLIB_INT_SourceDisable (INT_ID_0 , source);
00000038  00000000   NOP
194:                 
195:                     /* restore the state of CP0 Status register before the disable occurred*/
196:                     PLIB_INT_SetState(INT_ID_0 , processorStatus);
00000048  00000000   NOP
197:                 
198:                     /* return the source status */
199:                     return intSrcStatus;
00000058  00000000   NOP
200:                 }
0000005C  00000000   NOP
201:                 
202:                 
203:                 // *****************************************************************************
204:                 /* Sets the external interrupt trigger type.
205:                 
206:                   Summary:
207:                     Sets the external interrupt trigger type.
208:                 
209:                   Description:
210:                     This function sets the External interrupt trigger type.
211:                 
212:                   Remarks:
213:                     Refer the datasheet to know the external interrupt sources supported.
214:                  */
215:                 
216:                 void SYS_INT_ExternalInterruptTriggerSet ( 	INT_EXTERNAL_SOURCES source,
217:                 										INT_EXTERNAL_EDGE_TRIGGER edgeTrigger )
218:                 {
00000000  00000000   NOP
219:                 	if ( edgeTrigger == INT_EDGE_TRIGGER_RISING )
00000018  00000000   NOP
220:                 	{
221:                 		PLIB_INT_ExternalRisingEdgeSelect ( INT_ID_0, source );
00000028  00000000   NOP
222:                 	}
223:                 	else
224:                 	{
225:                 		PLIB_INT_ExternalFallingEdgeSelect ( INT_ID_0, source );
00000040  00000000   NOP
226:                 	}
227:                 }
00000050  00000000   NOP
228:                 
---  /home/david/microchip/harmony/v1_05/framework/system/devcon/src/sys_devcon_pic32mx.c  --------------
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "sys_devcon_local.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  #include "peripheral/osc/plib_osc.h"
55:                  #include "peripheral/pcache/plib_pcache.h"
56:                  #include "peripheral/bmx/plib_bmx.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  //
70:                  #ifndef PCACHE_ID_0
71:                  #define PCACHE_ID_0 0
72:                  #endif
73:                  #ifndef PLIB_PCACHE_PREFETCH_ENABLE_ALL
74:                  #define PLIB_PCACHE_PREFETCH_ENABLE_ALL 3
75:                  #endif
76:                  
77:                  // *****************************************************************************
78:                  /* Function:
79:                      void SYS_DEVCON_PerformanceConfig( void )
80:                  
81:                    Summary:
82:                      Configures the PFM wait states and prefetch (cache) module for maximum 
83:                      performance.
84:                  
85:                    Description:
86:                      This function configures the PFM wait states and prefetch (cache) module 
87:                      for maximum performance.
88:                  
89:                    Remarks:
90:                      None.
91:                  */
92:                  
93:                  void __attribute__((nomips16)) SYS_DEVCON_PerformanceConfig( unsigned int sysclk )
94:                  {
9D000A08  27BDFFE0   ADDIU SP, SP, -32
9D000A0C  AFBF001C   SW RA, 28(SP)
9D000A10  AFBE0018   SW S8, 24(SP)
9D000A14  03A0F021   ADDU S8, SP, ZERO
9D000A18  AFC40020   SW A0, 32(S8)
95:                      bool int_flag = false;
9D000A1C  A3C00014   SB ZERO, 20(S8)
96:                      register unsigned long tmp;
97:                  
98:                      /* Set kseg0 coherency algorithm to "cacheable, non-coherent, write-back, 
99:                       * write-allocate. This is needed for the prefetch buffer */
100:                     asm("mfc0 %0,$16,0" :  "=r"(tmp));
9D000A20  40028000   MFC0 V0, Config
9D000A24  0040F821   ADDU RA, V0, ZERO
101:                     tmp = (tmp & ~7) | 3;
9D000A28  2402FFF8   ADDIU V0, ZERO, -8
9D000A2C  03E21024   AND V0, RA, V0
9D000A30  345F0003   ORI RA, V0, 3
102:                     asm("mtc0 %0,$16,0" :: "r" (tmp));
9D000A34  409F8000   MTC0 RA, Config
103:                 
104:                     /* Set the PFM wait states based on the system clock */
105:                     #if defined(PLIB_PCACHE_ExistsWaitState)
106:                     if (PLIB_PCACHE_ExistsWaitState(PCACHE_ID_0))
9D000A38  0F400C02   JAL 0x9D003008
9D000A3C  00002021   ADDU A0, ZERO, ZERO
9D000A40  10400023   BEQ V0, ZERO, 0x9D000AD0
9D000A44  00000000   NOP
107:                     {
108:                         int ws; /* number of wait states */
109:                         if (sysclk <= 30000000)
9D000A48  8FC30020   LW V1, 32(S8)
9D000A4C  3C0201C9   LUI V0, 457
9D000A50  3442C381   ORI V0, V0, -15487
9D000A54  0062102B   SLTU V0, V1, V0
9D000A58  10400003   BEQ V0, ZERO, 0x9D000A68
9D000A5C  00000000   NOP
110:                             ws = 0;
9D000A60  0B4002A5   J 0x9D000A94
9D000A64  AFC00010   SW ZERO, 16(S8)
111:                         else if (sysclk <= 60000000)
9D000A68  8FC30020   LW V1, 32(S8)
9D000A6C  3C020393   LUI V0, 915
9D000A70  34428701   ORI V0, V0, -30975
9D000A74  0062102B   SLTU V0, V1, V0
9D000A78  10400004   BEQ V0, ZERO, 0x9D000A8C
9D000A7C  00000000   NOP
112:                             ws = 1;
9D000A80  24020001   ADDIU V0, ZERO, 1
9D000A84  0B4002A5   J 0x9D000A94
9D000A88  AFC20010   SW V0, 16(S8)
113:                         else
114:                             ws = 2;
9D000A8C  24020002   ADDIU V0, ZERO, 2
9D000A90  AFC20010   SW V0, 16(S8)
115:                 
116:                         /* Interrupts must be disabled when changing wait states */
117:                         int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D000A94  0F400B20   JAL 0x9D002C80
9D000A98  00002021   ADDU A0, ZERO, ZERO
9D000A9C  30420001   ANDI V0, V0, 1
9D000AA0  0002102B   SLTU V0, ZERO, V0
9D000AA4  A3C20014   SB V0, 20(S8)
118:                 
119:                         PLIB_PCACHE_WaitStateSet(PCACHE_ID_0, ws);
9D000AA8  8FC20010   LW V0, 16(S8)
9D000AAC  00002021   ADDU A0, ZERO, ZERO
9D000AB0  0F400B80   JAL 0x9D002E00
9D000AB4  00402821   ADDU A1, V0, ZERO
120:                 
121:                         if (int_flag)
9D000AB8  93C20014   LBU V0, 20(S8)
9D000ABC  10400004   BEQ V0, ZERO, 0x9D000AD0
9D000AC0  00000000   NOP
122:                         {
123:                             PLIB_INT_Enable(INT_ID_0);
9D000AC4  0F400ABC   JAL 0x9D002AF0
9D000AC8  00002021   ADDU A0, ZERO, ZERO
124:                             int_flag = false;
9D000ACC  A3C00014   SB ZERO, 20(S8)
125:                         }
126:                     }
127:                     #endif // defined(PLIB_PCACHE_ExistsWaitState)
128:                 
129:                     /* Interrupts must be disabled when enabling the Prefetch Cache Module */
130:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D000AD0  0F400B20   JAL 0x9D002C80
9D000AD4  00002021   ADDU A0, ZERO, ZERO
9D000AD8  30420001   ANDI V0, V0, 1
9D000ADC  0002102B   SLTU V0, ZERO, V0
9D000AE0  A3C20014   SB V0, 20(S8)
131:                 
132:                     /* Enable Prefetch Cache Module */
133:                     #if defined(PLIB_PCACHE_ExistsPrefetchEnable)
134:                     if (PLIB_PCACHE_ExistsPrefetchEnable(PCACHE_ID_0))
9D000AE4  0F400C04   JAL 0x9D003010
9D000AE8  00002021   ADDU A0, ZERO, ZERO
9D000AEC  10400004   BEQ V0, ZERO, 0x9D000B00
9D000AF0  00000000   NOP
135:                     {
136:                         PLIB_PCACHE_PrefetchEnableSet(PCACHE_ID_0, PLIB_PCACHE_PREFETCH_ENABLE_ALL);
9D000AF4  00002021   ADDU A0, ZERO, ZERO
9D000AF8  0F400B2B   JAL 0x9D002CAC
9D000AFC  24050003   ADDIU A1, ZERO, 3
137:                     }
138:                     #endif
139:                 
140:                     /* Set the SRAM wait states to zero */
141:                     if (PLIB_BMX_ExistsDataRamWaitState(BMX_ID_0))
9D000B00  0F400C00   JAL 0x9D003000
9D000B04  00002021   ADDU A0, ZERO, ZERO
9D000B08  10400004   BEQ V0, ZERO, 0x9D000B1C
9D000B0C  00000000   NOP
142:                     {
143:                         PLIB_BMX_DataRamWaitStateSet(BMX_ID_0, PLIB_BMX_DATA_RAM_WAIT_ZERO);
9D000B10  00002021   ADDU A0, ZERO, ZERO
9D000B14  0F400B0A   JAL 0x9D002C28
9D000B18  00002821   ADDU A1, ZERO, ZERO
144:                     }            
145:                     
146:                     if (int_flag)
9D000B1C  93C20014   LBU V0, 20(S8)
9D000B20  10400003   BEQ V0, ZERO, 0x9D000B30
9D000B24  00000000   NOP
147:                     {
148:                         PLIB_INT_Enable(INT_ID_0);
9D000B28  0F400ABC   JAL 0x9D002AF0
9D000B2C  00002021   ADDU A0, ZERO, ZERO
149:                     }
150:                 }
9D000B30  03C0E821   ADDU SP, S8, ZERO
9D000B34  8FBF001C   LW RA, 28(SP)
9D000B38  8FBE0018   LW S8, 24(SP)
9D000B3C  03E00008   JR RA
9D000B40  27BD0020   ADDIU SP, SP, 32
151:                 
152:                 /*******************************************************************************
153:                  End of File
154:                 */
155:                 
---  /home/david/microchip/harmony/v1_05/framework/system/devcon/src/sys_devcon.c  ----------------------
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "sys_devcon_local.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  #include "peripheral/devcon/plib_devcon.h"
55:                  #include "peripheral/osc/plib_osc.h"
56:                  #include "system/int/sys_int.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  /* System Device Control Instance */
71:                  SYS_DEVCON_OBJECT sysDevconObj;
72:                  
73:                  
74:                  // *****************************************************************************
75:                  // *****************************************************************************
76:                  // Section: SYS DEVCON Module Initialization Routines
77:                  // *****************************************************************************
78:                  // *****************************************************************************
79:                  
80:                  // *****************************************************************************
81:                  /* Function:
82:                      SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX           index,
83:                                                         const SYS_MODULE_INIT * const    init )
84:                  
85:                    Summary:
86:                      Initializes data for the instance of the Device Control module and opens
87:                      the specific module instance.
88:                  
89:                    Description:
90:                      This function initializes the instance of the Device Control module,
91:                      using the specified initialization data. It also initializes any
92:                      internal data structures.
93:                  
94:                    Remarks:
95:                      This routine should only be called once during system initialization
96:                      unless SYS_DEVCON_Deinitialize is first called to deinitialize the device
97:                      instance before reinitializing it. If the system was already initialized
98:                      it safely returns without causing any disturbance.
99:                  */
100:                 
101:                 SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX index,
102:                                                    const SYS_MODULE_INIT * const init )
103:                 {
9D0028AC  27BDFFF8   ADDIU SP, SP, -8
9D0028B0  AFBE0004   SW S8, 4(SP)
9D0028B4  03A0F021   ADDU S8, SP, ZERO
9D0028B8  00801021   ADDU V0, A0, ZERO
9D0028BC  AFC5000C   SW A1, 12(S8)
9D0028C0  A7C20008   SH V0, 8(S8)
104:                     sysDevconObj.status = SYS_STATUS_READY;
9D0028C4  24020002   ADDIU V0, ZERO, 2
9D0028C8  AF82802C   SW V0, -32724(GP)
105:                 
106:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
9D0028CC  AF808028   SW ZERO, -32728(GP)
107:                 
108:                     return (SYS_MODULE_OBJ)SYS_DEVCON_INDEX_0;
9D0028D0  00001021   ADDU V0, ZERO, ZERO
109:                 }
9D0028D4  03C0E821   ADDU SP, S8, ZERO
9D0028D8  8FBE0004   LW S8, 4(SP)
9D0028DC  27BD0008   ADDIU SP, SP, 8
9D0028E0  03E00008   JR RA
9D0028E4  00000000   NOP
110:                 
111:                 
112:                 // *****************************************************************************
113:                 /* Function:
114:                     void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ                  object,
115:                                                const SYS_MODULE_INIT * const   init )
116:                 
117:                    Summary:
118:                     Reinitializes and refreshes the hardware for the instance of the Device 
119:                     Control module.
120:                 
121:                    Description:
122:                     This function reinitializes the instance of the Device Control module using 
123:                     the supplied data. It modifies the internal data structure.
124:                 
125:                    Remarks:
126:                     This operation uses the same initialization data structure as the
127:                     SYS_DEVCON_Initialize operation. This operation can be used to change the
128:                     power state of a DEVCON module. This function can be called multiple times
129:                     to reinitialize the module. This operation uses the same initialization
130:                     data structure as the Initialize operation. This operation can also be
131:                     used to refresh the hardware registers as defined by the initialization
132:                     data.
133:                 */
134:                 
135:                 void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ object,
136:                                            const SYS_MODULE_INIT * const init )
137:                 {
00000000  00000000   NOP
138:                     sysDevconObj.status = SYS_STATUS_READY;
00000014  00000000   NOP
139:                 
140:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
0000001C  00000000   NOP
141:                 }
00000020  00000000   NOP
142:                 
143:                 
144:                 // *****************************************************************************
145:                 /* Function:
146:                     void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
147:                 
148:                   Summary:
149:                     Deinitializes the specific module instance of the DEVCON module
150:                 
151:                   Description:
152:                     This function deinitializes the specific module instance disabling its operation 
153:                     (and any hardware for driver modules). Resets all of the internal data
154:                     structures and fields for the specified instance to the default settings.
155:                 
156:                   Remarks:
157:                     Once the Initialize operation has been called, the Deinitialize
158:                     operation must be called before the Initialize operation can be called
159:                     again.
160:                 */
161:                 
162:                 void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
163:                 {
00000000  00000000   NOP
164:                     sysDevconObj.status = SYS_STATUS_UNINITIALIZED;
00000010  00000000   NOP
165:                 }
00000014  00000000   NOP
166:                 
167:                 
168:                 // *****************************************************************************
169:                 /* Function:
170:                     SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
171:                 
172:                   Summary:
173:                     Returns status of the specific instance of the Device Control module.
174:                 
175:                   Description:
176:                     This function returns the status of the specific module instance.
177:                 
178:                   Remarks:
179:                     None.
180:                 */
181:                 
182:                 SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
183:                 {
00000000  00000000   NOP
184:                     return sysDevconObj.status; 
00000010  00000000   NOP
185:                 }
00000014  00000000   NOP
186:                 
187:                 
188:                 // *****************************************************************************
189:                 /* Function:
190:                     void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
191:                 
192:                   Summary:
193:                     Maintains the system Device Control state machine.
194:                 
195:                   Description:
196:                     This function is used to maintain the system Device Control internal state machine.
197:                 
198:                   Remarks:
199:                     This function is normally not called directly by an application.  It is
200:                     called by the system's Tasks routine (SYS_Tasks) or by the apropriate raw
201:                     ISR.
202:                 */
203:                 
204:                 void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
205:                 {
9D002DB0  27BDFFF8   ADDIU SP, SP, -8
9D002DB4  AFBE0004   SW S8, 4(SP)
9D002DB8  03A0F021   ADDU S8, SP, ZERO
9D002DBC  AFC40008   SW A0, 8(S8)
206:                     switch (sysDevconObj.state)
207:                     {
208:                         case SYS_DEVCON_STATE_INIT:
209:                         case SYS_DEVCON_STATE_BUSY:
210:                         case SYS_DEVCON_STATE_READY:
211:                         default:
212:                             break;
9D002DC0  00000000   NOP
213:                     }
214:                 }
9D002DC4  03C0E821   ADDU SP, S8, ZERO
9D002DC8  8FBE0004   LW S8, 4(SP)
9D002DCC  27BD0008   ADDIU SP, SP, 8
9D002DD0  03E00008   JR RA
9D002DD4  00000000   NOP
215:                 
216:                     
217:                 // *****************************************************************************
218:                 // *****************************************************************************
219:                 // Section: SYS DEVCON Client Setup Routines
220:                 // *****************************************************************************
221:                 // *****************************************************************************
222:                 
223:                 // *****************************************************************************
224:                 /* Function:
225:                     void SYS_DEVCON_SystemUnlock( void )
226:                 
227:                   Summary:
228:                     Performs a system unlock sequence by writing to the SYSKEY register.
229:                 
230:                   Description:
231:                     Performs a system unlock sequence by writing to the SYSKEY register. A 
232:                     system unlock sequence is required before performing certain actions such
233:                     as changing a clock frequency or IO unlocking.
234:                 
235:                   Remarks:
236:                     None.
237:                 */
238:                 
239:                 void SYS_DEVCON_SystemUnlock( void )
240:                 {
9D001F0C  27BDFFE0   ADDIU SP, SP, -32
9D001F10  AFBF001C   SW RA, 28(SP)
9D001F14  AFBE0018   SW S8, 24(SP)
9D001F18  03A0F021   ADDU S8, SP, ZERO
241:                     bool int_flag = false;
9D001F1C  A3C00010   SB ZERO, 16(S8)
242:                 
243:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D001F20  00002021   ADDU A0, ZERO, ZERO
9D001F24  0F400B20   JAL 0x9D002C80
9D001F28  00000000   NOP
9D001F2C  30420001   ANDI V0, V0, 1
9D001F30  0002102B   SLTU V0, ZERO, V0
9D001F34  A3C20010   SB V0, 16(S8)
244:                 
245:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
9D001F38  00002021   ADDU A0, ZERO, ZERO
9D001F3C  0F400B15   JAL 0x9D002C54
9D001F40  00000000   NOP
246:                 
247:                     if (int_flag)
9D001F44  93C20010   LBU V0, 16(S8)
9D001F48  10400004   BEQ V0, ZERO, 0x9D001F5C
9D001F4C  00000000   NOP
248:                     {
249:                         PLIB_INT_Enable(INT_ID_0);
9D001F50  00002021   ADDU A0, ZERO, ZERO
9D001F54  0F400ABC   JAL 0x9D002AF0
9D001F58  00000000   NOP
250:                     }
251:                 }
9D001F5C  03C0E821   ADDU SP, S8, ZERO
9D001F60  8FBF001C   LW RA, 28(SP)
9D001F64  8FBE0018   LW S8, 24(SP)
9D001F68  27BD0020   ADDIU SP, SP, 32
9D001F6C  03E00008   JR RA
9D001F70  00000000   NOP
252:                 
253:                 
254:                 // *****************************************************************************
255:                 /* Function:
256:                     void SYS_DEVCON_SystemLock( void )
257:                 
258:                   Summary:
259:                     Performs a system lock sequence by writing to the SYSKEY register.
260:                 
261:                   Description:
262:                     Performs a system lock sequence by writing to the SYSKEY register. A 
263:                     system lock sequence is required after performing the action that required
264:                     a system lock sequence.
265:                 
266:                   Remarks:
267:                     None.
268:                 */
269:                 
270:                 void SYS_DEVCON_SystemLock( void )
271:                 {
9D001F74  27BDFFE0   ADDIU SP, SP, -32
9D001F78  AFBF001C   SW RA, 28(SP)
9D001F7C  AFBE0018   SW S8, 24(SP)
9D001F80  03A0F021   ADDU S8, SP, ZERO
272:                     bool int_flag = false;
9D001F84  A3C00010   SB ZERO, 16(S8)
273:                    
274:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D001F88  00002021   ADDU A0, ZERO, ZERO
9D001F8C  0F400B20   JAL 0x9D002C80
9D001F90  00000000   NOP
9D001F94  30420001   ANDI V0, V0, 1
9D001F98  0002102B   SLTU V0, ZERO, V0
9D001F9C  A3C20010   SB V0, 16(S8)
275:                 
276:                     PLIB_DEVCON_SystemLock(DEVCON_ID_0);
9D001FA0  00002021   ADDU A0, ZERO, ZERO
9D001FA4  0F400BDE   JAL 0x9D002F78
9D001FA8  00000000   NOP
277:                 
278:                     if (int_flag)
9D001FAC  93C20010   LBU V0, 16(S8)
9D001FB0  10400004   BEQ V0, ZERO, 0x9D001FC4
9D001FB4  00000000   NOP
279:                     {
280:                         PLIB_INT_Enable(INT_ID_0);
9D001FB8  00002021   ADDU A0, ZERO, ZERO
9D001FBC  0F400ABC   JAL 0x9D002AF0
9D001FC0  00000000   NOP
281:                     }
282:                 }
9D001FC4  03C0E821   ADDU SP, S8, ZERO
9D001FC8  8FBF001C   LW RA, 28(SP)
9D001FCC  8FBE0018   LW S8, 24(SP)
9D001FD0  27BD0020   ADDIU SP, SP, 32
9D001FD4  03E00008   JR RA
9D001FD8  00000000   NOP
283:                 
284:                 
285:                 // *****************************************************************************
286:                 /* Function:
287:                     void SYS_DEVCON_JTAGEnable( void )
288:                 
289:                   Summary:
290:                     Enables the JTAG port on the device.
291:                 
292:                   Description:
293:                     Enables the JTAG port on the device.
294:                 
295:                   Remarks:
296:                     None.
297:                 */
298:                 
299:                 void SYS_DEVCON_JTAGEnable( void )
300:                 {
00000000  00000000   NOP
301:                     PLIB_DEVCON_JTAGPortEnable(DEVCON_ID_0);
00000010  00000000   NOP
302:                 }
0000001C  00000000   NOP
303:                 
304:                 
305:                 // *****************************************************************************
306:                 /* Function:
307:                     void SYS_DEVCON_JTAGDisable( void )
308:                 
309:                   Summary:
310:                     Disables the JTAG port on the device.
311:                 
312:                   Description:
313:                     Disables the JTAG port on the device.
314:                 
315:                   Remarks:
316:                     None.
317:                 */
318:                 
319:                 void SYS_DEVCON_JTAGDisable( void )
320:                 {
00000000  00000000   NOP
321:                     PLIB_DEVCON_JTAGPortDisable(DEVCON_ID_0);
00000010  00000000   NOP
322:                 }
0000001C  00000000   NOP
323:                 
324:                 
325:                 // *****************************************************************************
326:                 /* Function:
327:                     void SYS_DEVCON_TraceEnable( void )
328:                 
329:                   Summary:
330:                     Enables the Trace output port on the device.
331:                 
332:                   Description:
333:                     Enables the Trace output port on the device.
334:                 
335:                   Remarks:
336:                     None.
337:                 */
338:                 
339:                 void SYS_DEVCON_TraceEnable( void )
340:                 {
00000000  00000000   NOP
341:                     PLIB_DEVCON_TraceOutputEnable(DEVCON_ID_0);
00000010  00000000   NOP
342:                 }
0000001C  00000000   NOP
343:                 
344:                 
345:                 // *****************************************************************************
346:                 /* Function:
347:                     void SYS_DEVCON_TraceDisable( void )
348:                 
349:                   Summary:
350:                     Disables the Trace output port on the device.
351:                 
352:                   Description:
353:                     Disables the Trace output port on the device.
354:                 
355:                   Remarks:
356:                     None.
357:                 */
358:                 
359:                 void SYS_DEVCON_TraceDisable( void )
360:                 {
00000000  00000000   NOP
361:                     PLIB_DEVCON_TraceOutputDisable(DEVCON_ID_0);
00000010  00000000   NOP
362:                 }
0000001C  00000000   NOP
363:                 
364:                 
365:                 // *****************************************************************************
366:                 /* Function:
367:                     void SYS_DEVCON_PowerModeEnter(SYS_POWER_MODE pwrMode)
368:                 
369:                   Summary:
370:                     Puts the device in a low-power state.
371:                 
372:                   Description:
373:                     Puts the device in a low-power state.
374:                 
375:                   Remarks:
376:                     None.
377:                 */
378:                 
379:                 void __attribute__((nomips16)) SYS_DEVCON_PowerModeEnter( SYS_POWER_MODE pwrMode )
380:                 {
00000000  00000000   NOP
381:                     OSC_OPERATION_ON_WAIT op = SYS_POWER_MODE_IDLE;
00000014  00000000   NOP
382:                 
383:                     switch (pwrMode)
00000018  00000000   NOP
384:                     {
385:                         case SYS_POWER_MODE_IDLE:
386:                             op = OSC_ON_WAIT_IDLE;
387:                             break;
00000038  00000000   NOP
388:                         case SYS_POWER_MODE_SLEEP:
389:                             op = OSC_ON_WAIT_SLEEP;
00000040  00000000   NOP
390:                             break;
00000048  00000000   NOP
391:                         default:
392:                             break;
00000030  00000000   NOP
393:                     }
394:                 
395:                     SYS_DEVCON_SystemUnlock();
0000004C  00000000   NOP
396:                     PLIB_OSC_OnWaitActionSet (OSC_ID_0, op);
00000054  00000000   NOP
397:                     SYS_DEVCON_SystemLock();
00000060  00000000   NOP
398:                 
399:                     asm volatile ( "wait" );
00000068  00000000   NOP
400:                 }
0000006C  00000000   NOP
401:                 
402:                 
403:                 /*******************************************************************************
404:                  End of File
405:                 */
406:                 
---  /home/david/microchip/harmony/projects/einkdisplay/firmware/src/system_config/default/system_tasks.c
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       system_tasks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to maintain system's polled state
9:                       machines.
10:                  
11:                    Description:
12:                      This file contains source code necessary to maintain system's polled state
13:                      machines.  It implements the "SYS_Tasks" function that calls the individual
14:                      "Tasks" functions for all polled MPLAB Harmony modules in the system.
15:                  
16:                    Remarks:
17:                      This file requires access to the systemObjects global data structure that
18:                      contains the object handles to all MPLAB Harmony module objects executing
19:                      polled in the system.  These handles are passed into the individual module
20:                      "Tasks" functions to identify the instance of the module to maintain.
21:                   *******************************************************************************/
22:                  
23:                  // DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                   *******************************************************************************/
46:                  // DOM-IGNORE-END
47:                  
48:                  
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  // Section: Included Files
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  
55:                  #include "system_config.h"
56:                  #include "system_definitions.h"
57:                  
58:                  
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  // Section: System "Tasks" Routine
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  
65:                  /*******************************************************************************
66:                    Function:
67:                      void SYS_Tasks ( void )
68:                  
69:                    Remarks:
70:                      See prototype in system/common/sys_module.h.
71:                  */
72:                  
73:                  void SYS_Tasks ( void )
74:                  {
9D0025F0  27BDFFE8   ADDIU SP, SP, -24
9D0025F4  AFBF0014   SW RA, 20(SP)
9D0025F8  AFBE0010   SW S8, 16(SP)
9D0025FC  03A0F021   ADDU S8, SP, ZERO
75:                      /* Maintain system services */
76:                      SYS_DEVCON_Tasks(sysObj.sysDevcon);
9D002600  8F82801C   LW V0, -32740(GP)
9D002604  00402021   ADDU A0, V0, ZERO
9D002608  0F400B6C   JAL SYS_DEVCON_Tasks
9D00260C  00000000   NOP
77:                  
78:                      /* Maintain Device Drivers */
79:                  
80:                      /* Maintain Middleware & Other Libraries */
81:                  
82:                  
83:                      /* Maintain the application's state machine. */
84:                      APP_Tasks();
9D002610  0F4000DC   JAL APP_Tasks
9D002614  00000000   NOP
85:                  }
9D002618  03C0E821   ADDU SP, S8, ZERO
9D00261C  8FBF0014   LW RA, 20(SP)
9D002620  8FBE0010   LW S8, 16(SP)
9D002624  27BD0018   ADDIU SP, SP, 24
9D002628  03E00008   JR RA
9D00262C  00000000   NOP
86:                  
87:                  
88:                  /*******************************************************************************
89:                   End of File
90:                   */
91:                  
---  /home/david/microchip/harmony/projects/einkdisplay/firmware/src/system_config/default/system_init.c  
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       system_init.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits, 
13:                      and allocates any necessary global system resources, such as the 
14:                      sysObj structure that contains the object handles to all the MPLAB Harmony 
15:                      module objects in the system.
16:                   *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  #include "system_config.h"
51:                  #include "system_definitions.h"
52:                  
53:                  
54:                  // ****************************************************************************
55:                  // ****************************************************************************
56:                  // Section: Configuration Bits
57:                  // ****************************************************************************
58:                  // ****************************************************************************
59:                  // <editor-fold defaultstate="collapsed" desc="Configuration Bits">
60:                  
61:                  /*** DEVCFG0 ***/
62:                  
63:                  #pragma config DEBUG =      OFF
64:                  #pragma config JTAGEN =     OFF
65:                  #pragma config ICESEL =     ICS_PGx2
66:                  #pragma config PWP =        OFF
67:                  #pragma config BWP =        OFF
68:                  #pragma config CP =         OFF
69:                  
70:                  /*** DEVCFG1 ***/
71:                  
72:                  #pragma config FNOSC =      FRCDIV
73:                  #pragma config FSOSCEN =    OFF
74:                  #pragma config IESO =       ON
75:                  #pragma config POSCMOD =    OFF
76:                  #pragma config OSCIOFNC =   OFF
77:                  #pragma config FPBDIV =     DIV_8
78:                  #pragma config FCKSM =      CSDCMD
79:                  #pragma config WDTPS =      PS1048576
80:                  #pragma config FWDTEN =     OFF
81:                  #pragma config WINDIS =     OFF
82:                  #pragma config FWDTWINSZ =  WINSZ_25
83:                  
84:                  /*** DEVCFG2 ***/
85:                  
86:                  #pragma config FPLLIDIV =   DIV_2
87:                  #pragma config FPLLMUL =    MUL_24
88:                  #pragma config FPLLODIV =   DIV_1
89:                  
90:                  /*** DEVCFG3 ***/
91:                  
92:                  #pragma config USERID =     0xffff
93:                  #pragma config FSRSSEL =    PRIORITY_7
94:                  #pragma config PMDL1WAY =   ON
95:                  #pragma config IOL1WAY =    ON
96:                  // </editor-fold>
97:                  
98:                  
99:                  // *****************************************************************************
100:                 // *****************************************************************************
101:                 // Section: Library/Stack Initialization Data
102:                 // *****************************************************************************
103:                 // *****************************************************************************
104:                 
105:                 
106:                 
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 // Section: Driver Initialization Data
110:                 // *****************************************************************************
111:                 // *****************************************************************************
112:                 
113:                 //<editor-fold defaultstate="collapsed" desc="DRV_Timer Initialization Data">
114:                 
115:                 // </editor-fold>
116:                 //<editor-fold defaultstate="collapsed" desc="DRV_USART Initialization Data">
117:                 
118:                 // </editor-fold>
119:                 
120:                 // *****************************************************************************
121:                 // *****************************************************************************
122:                 // Section: System Data
123:                 // *****************************************************************************
124:                 // *****************************************************************************
125:                 
126:                 /* Structure to hold the object handles for the modules in the system. */
127:                 SYSTEM_OBJECTS sysObj;
128:                 
129:                 
130:                 // *****************************************************************************
131:                 // *****************************************************************************
132:                 // Section: Module Initialization Data
133:                 // *****************************************************************************
134:                 // *****************************************************************************
135:                 
136:                 /*******************************************************************************
137:                   Device Control System Service Initialization Data
138:                   
139:                   <editor-fold defaultstate="collapsed" 
140:                   desc="Device Control System Service Initialization Data">
141:                 */
142:                 
143:                 const SYS_DEVCON_INIT sysDevconInit =
144:                 {
145:                     .moduleInit = {0},
146:                 };
147:                 
148:                 // </editor-fold>
149:                 
150:                 
151:                 // *****************************************************************************
152:                 // *****************************************************************************
153:                 // Section: Static Initialization Functions
154:                 // *****************************************************************************
155:                 // *****************************************************************************
156:                 
157:                 
158:                 // *****************************************************************************
159:                 // *****************************************************************************
160:                 // Section: System Initialization
161:                 // *****************************************************************************
162:                 // *****************************************************************************
163:                 
164:                 /*******************************************************************************
165:                   Function:
166:                     void SYS_Initialize ( SYS_INIT_DATA *data )
167:                 
168:                   Summary:
169:                     Initializes the board, services, drivers, application and other modules.
170:                 
171:                   Remarks:
172:                     See prototype in system/common/sys_module.h.
173:                  */
174:                 
175:                 void SYS_Initialize ( void* data )
176:                 {
9D00171C  27BDFFE8   ADDIU SP, SP, -24
9D001720  AFBF0014   SW RA, 20(SP)
9D001724  AFBE0010   SW S8, 16(SP)
9D001728  03A0F021   ADDU S8, SP, ZERO
9D00172C  AFC40018   SW A0, 24(S8)
177:                     /* Core Processor Initialization */
178:                     SYS_CLK_Initialize( NULL );
9D001730  00002021   ADDU A0, ZERO, ZERO
9D001734  0F4006A5   JAL SYS_CLK_Initialize
9D001738  00000000   NOP
179:                     sysObj.sysDevcon = SYS_DEVCON_Initialize(SYS_DEVCON_INDEX_0, (SYS_MODULE_INIT*)&sysDevconInit);
9D00173C  00002021   ADDU A0, ZERO, ZERO
9D001740  3C029D00   LUI V0, -25344
9D001744  24453028   ADDIU A1, V0, 12328
9D001748  0F400A2B   JAL SYS_DEVCON_Initialize
9D00174C  00000000   NOP
9D001750  AF82801C   SW V0, -32740(GP)
180:                     SYS_DEVCON_PerformanceConfig(SYS_CLK_SystemFrequencyGet());
9D001754  0F400B62   JAL SYS_CLK_SystemFrequencyGet
9D001758  00000000   NOP
9D00175C  00402021   ADDU A0, V0, ZERO
9D001760  0F400282   JAL SYS_DEVCON_PerformanceConfig
9D001764  00000000   NOP
181:                     SYS_PORTS_Initialize();
9D001768  0F400000   JAL SYS_PORTS_Initialize
9D00176C  00000000   NOP
182:                 
183:                     /* Initialize Drivers */
184:                     /* Initialize ADC */
185:                     DRV_ADC_Initialize();
9D001770  0F400364   JAL DRV_ADC_Initialize
9D001774  00000000   NOP
186:                     /*Initialize TMR0 */
187:                     DRV_TMR0_Initialize();
9D001778  0F4006C5   JAL DRV_TMR0_Initialize
9D00177C  00000000   NOP
188:                  
189:                      DRV_USART0_Initialize();
9D001780  0F4004DE   JAL DRV_USART0_Initialize
9D001784  00000000   NOP
190:                 
191:                     /* Initialize System Services */
192:                     SYS_INT_Initialize();  
9D001788  0F400A72   JAL SYS_INT_Initialize
9D00178C  00000000   NOP
193:                 
194:                     /* Initialize Middleware */
195:                     /* Enable Global Interrupts */
196:                     SYS_INT_Enable();
9D001790  00002021   ADDU A0, ZERO, ZERO
9D001794  0F400ABC   JAL 0x9D002AF0
9D001798  00000000   NOP
197:                 
198:                     /* Initialize the Application */
199:                     APP_Initialize();
9D00179C  0F4008B8   JAL APP_Initialize
9D0017A0  00000000   NOP
200:                 }
9D0017A4  03C0E821   ADDU SP, S8, ZERO
9D0017A8  8FBF0014   LW RA, 20(SP)
9D0017AC  8FBE0010   LW S8, 16(SP)
9D0017B0  27BD0018   ADDIU SP, SP, 24
9D0017B4  03E00008   JR RA
9D0017B8  00000000   NOP
201:                 
202:                 
203:                 /*******************************************************************************
204:                  End of File
205:                 */
206:                 
---  /home/david/microchip/harmony/projects/einkdisplay/firmware/src/system_config/default/system_exceptions.c
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       system_exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the deafult _weak_ exception 
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occured.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  
45:                  #include <xc.h>                 /* Defines special funciton registers, CP0 regs  */
46:                  #include "system_config.h"
47:                  #include "system_definitions.h"
48:                  #include "system/debug/sys_debug.h"
49:                  
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Global Data Definitions
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  /*******************************************************************************
58:                    Exception Reason Data
59:                    
60:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
61:                    
62:                    Remarks:
63:                      These global static items are used instead of local variables in the 
64:                      _general_exception_handler function because the stack may not be available
65:                      if an exception has occured.
66:                  */
67:                  
68:                  /* Code identifying the cause of the exception (CP0 Cause register). */
69:                  static unsigned int _excep_code;
70:                  
71:                  /* Address of instruction that caused the exception. */
72:                  static unsigned int _excep_addr;
73:                  
74:                  /* Pointer to the string describing the cause of the exception. */
75:                  static char *_cause_str;
76:                  
77:                  /* Array identifying the cause (indexed by _exception_code). */
78:                  static char *cause[] = 
79:                  {
80:                      "Interrupt",
81:                      "Undefined",
82:                      "Undefined",
83:                      "Undefined",
84:                      "Load/fetch address error",
85:                      "Store address error",
86:                      "Instruction bus error",
87:                      "Data bus error",
88:                      "Syscall",
89:                      "Breakpoint",
90:                      "Reserved instruction",
91:                      "Coprocessor unusable",
92:                      "Arithmetic overflow",
93:                      "Trap",
94:                      "Reserved",
95:                      "Reserved",
96:                      "Reserved",
97:                      "Reserved",
98:                      "Reserved"
99:                  };
100:                 
101:                 // </editor-fold>
102:                 
103:                 
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 // Section: Exception Handling
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 
110:                 /*******************************************************************************
111:                   Function:
112:                     void _general_exception_handler ( void )
113:                 
114:                   Summary:
115:                     Overrides the XC32 _weak_ _generic_exception_handler.
116:                     
117:                   Description:
118:                     This function overrides the XC32 default _weak_ _generic_exception_handler.
119:                 
120:                   Remarks:
121:                     Refer to the XC32 User's Guide for additional information.
122:                  */
123:                 
124:                 void _general_exception_handler ( void )
125:                 {
9D002294  27BDFFF8   ADDIU SP, SP, -8
9D002298  AFBF0004   SW RA, 4(SP)
9D00229C  AFBE0000   SW S8, 0(SP)
9D0022A0  03A0F021   ADDU S8, SP, ZERO
126:                     /* Mask off Mask of the ExcCode Field from the Cause Register
127:                     Refer to the MIPs Software User's manual */
128:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D0022A4  40026800   MFC0 V0, Cause
9D0022A8  3042007C   ANDI V0, V0, 124
9D0022AC  00021082   SRL V0, V0, 2
9D0022B0  AF828010   SW V0, -32752(GP)
129:                     _excep_addr = _CP0_GET_EPC();
9D0022B4  40027000   MFC0 V0, EPC
9D0022B8  AF828014   SW V0, -32748(GP)
130:                     _cause_str  = cause[_excep_code];
9D0022BC  8F838010   LW V1, -32752(GP)
9D0022C0  3C02A000   LUI V0, -24576
9D0022C4  00031880   SLL V1, V1, 2
9D0022C8  24420020   ADDIU V0, V0, 32
9D0022CC  00621021   ADDU V0, V1, V0
9D0022D0  8C420000   LW V0, 0(V0)
9D0022D4  AF828018   SW V0, -32744(GP)
131:                 
132:                     SYS_DEBUG_PRINT(SYS_ERROR_ERROR, "\nGeneral Exception %s (cause=%d, addr=%x).\n", 
133:                                     _cause_str, _excep_code, _excep_addr);
134:                 
135:                     while (1)
136:                     {
137:                         SYS_DEBUG_BreakPoint();
138:                     }
9D0022D8  0B4008B6   J 0x9D0022D8
9D0022DC  00000000   NOP
139:                 }
140:                 
141:                 /*******************************************************************************
142:                  End of File
143:                 */
---  /home/david/microchip/harmony/projects/einkdisplay/firmware/src/system_config/default/framework/system/ports/src/sys_ports_static.c
1:                   /*******************************************************************************
2:                     SYS PORTS Static Functions for PORTS System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_ports_static.c
9:                   
10:                    Summary:
11:                      SYS PORTS static function implementations for the Ports System Service.
12:                  
13:                    Description:
14:                      The Ports System Service provides a simple interface to manage the ports
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Ports System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system ports configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                  
24:                  *******************************************************************************/
25:                  
26:                  //DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                  *******************************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  #include "system_config.h"
52:                  #include "peripheral/ports/plib_ports.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  
55:                  
56:                  void SYS_PORTS_Initialize(void)
57:                  {
9D000000  27BDFFE8   ADDIU SP, SP, -24
9D000004  AFBF0014   SW RA, 20(SP)
9D000008  AFBE0010   SW S8, 16(SP)
9D00000C  03A0F021   ADDU S8, SP, ZERO
58:                      
59:                      /* PORT B Initialization */
60:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ODC);
9D000010  00002021   ADDU A0, ZERO, ZERO
9D000014  24050001   ADDIU A1, ZERO, 1
9D000018  24060008   ADDIU A2, ZERO, 8
9D00001C  0F400B94   JAL 0x9D002E50
9D000020  00000000   NOP
61:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_LAT);
9D000024  00002021   ADDU A0, ZERO, ZERO
9D000028  24050001   ADDIU A1, ZERO, 1
9D00002C  24060010   ADDIU A2, ZERO, 16
9D000030  0F400BC6   JAL 0x9D002F18
9D000034  00000000   NOP
62:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_TRIS ^ 0xFFFF);
9D000038  00002021   ADDU A0, ZERO, ZERO
9D00003C  24050001   ADDIU A1, ZERO, 1
9D000040  24060032   ADDIU A2, ZERO, 50
9D000044  0F400B8A   JAL 0x9D002E28
9D000048  00000000   NOP
63:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_B);
9D00004C  00002021   ADDU A0, ZERO, ZERO
9D000050  24050001   ADDIU A1, ZERO, 1
9D000054  0F400BBC   JAL 0x9D002EF0
9D000058  00000000   NOP
64:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
9D00005C  00002021   ADDU A0, ZERO, ZERO
9D000060  24050001   ADDIU A1, ZERO, 1
9D000064  3406F1FA   ORI A2, ZERO, -3590
9D000068  24070001   ADDIU A3, ZERO, 1
9D00006C  0F400924   JAL 0x9D002490
9D000070  00000000   NOP
65:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNEN);
9D000074  00002021   ADDU A0, ZERO, ZERO
9D000078  24050001   ADDIU A1, ZERO, 1
9D00007C  00003021   ADDU A2, ZERO, ZERO
9D000080  0F400BB2   JAL 0x9D002EC8
9D000084  00000000   NOP
66:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPU);
9D000088  00002021   ADDU A0, ZERO, ZERO
9D00008C  24050001   ADDIU A1, ZERO, 1
9D000090  00003021   ADDU A2, ZERO, ZERO
9D000094  0F400BA8   JAL 0x9D002EA0
9D000098  00000000   NOP
67:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPD);
9D00009C  00002021   ADDU A0, ZERO, ZERO
9D0000A0  24050001   ADDIU A1, ZERO, 1
9D0000A4  00003021   ADDU A2, ZERO, ZERO
9D0000A8  0F400B9E   JAL 0x9D002E78
9D0000AC  00000000   NOP
68:                      
69:                      /* PORT C Initialization */
70:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_ODC);
9D0000B0  00002021   ADDU A0, ZERO, ZERO
9D0000B4  24050002   ADDIU A1, ZERO, 2
9D0000B8  00003021   ADDU A2, ZERO, ZERO
9D0000BC  0F400B94   JAL 0x9D002E50
9D0000C0  00000000   NOP
71:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_C,  SYS_PORT_C_LAT);
9D0000C4  00002021   ADDU A0, ZERO, ZERO
9D0000C8  24050002   ADDIU A1, ZERO, 2
9D0000CC  00003021   ADDU A2, ZERO, ZERO
9D0000D0  0F400BC6   JAL 0x9D002F18
9D0000D4  00000000   NOP
72:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_C,  SYS_PORT_C_TRIS ^ 0xFFFF);
9D0000D8  00002021   ADDU A0, ZERO, ZERO
9D0000DC  24050002   ADDIU A1, ZERO, 2
9D0000E0  24066FFF   ADDIU A2, ZERO, 28671
9D0000E4  0F400B8A   JAL 0x9D002E28
9D0000E8  00000000   NOP
73:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_C);
9D0000EC  00002021   ADDU A0, ZERO, ZERO
9D0000F0  24050002   ADDIU A1, ZERO, 2
9D0000F4  0F400BBC   JAL 0x9D002EF0
9D0000F8  00000000   NOP
74:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
9D0000FC  00002021   ADDU A0, ZERO, ZERO
9D000100  24050002   ADDIU A1, ZERO, 2
9D000104  3406FFFF   ORI A2, ZERO, -1
9D000108  24070001   ADDIU A3, ZERO, 1
9D00010C  0F400924   JAL 0x9D002490
9D000110  00000000   NOP
75:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_CNEN);
9D000114  00002021   ADDU A0, ZERO, ZERO
9D000118  24050002   ADDIU A1, ZERO, 2
9D00011C  00003021   ADDU A2, ZERO, ZERO
9D000120  0F400BB2   JAL 0x9D002EC8
9D000124  00000000   NOP
76:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_CNPU);
9D000128  00002021   ADDU A0, ZERO, ZERO
9D00012C  24050002   ADDIU A1, ZERO, 2
9D000130  00003021   ADDU A2, ZERO, ZERO
9D000134  0F400BA8   JAL 0x9D002EA0
9D000138  00000000   NOP
77:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_CNPD);
9D00013C  00002021   ADDU A0, ZERO, ZERO
9D000140  24050002   ADDIU A1, ZERO, 2
9D000144  00003021   ADDU A2, ZERO, ZERO
9D000148  0F400B9E   JAL 0x9D002E78
9D00014C  00000000   NOP
78:                      
79:                      /* PORT D Initialization */
80:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_ODC);
9D000150  00002021   ADDU A0, ZERO, ZERO
9D000154  24050003   ADDIU A1, ZERO, 3
9D000158  00003021   ADDU A2, ZERO, ZERO
9D00015C  0F400B94   JAL 0x9D002E50
9D000160  00000000   NOP
81:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_D,  SYS_PORT_D_LAT);
9D000164  00002021   ADDU A0, ZERO, ZERO
9D000168  24050003   ADDIU A1, ZERO, 3
9D00016C  00003021   ADDU A2, ZERO, ZERO
9D000170  0F400BC6   JAL 0x9D002F18
9D000174  00000000   NOP
82:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_D,  SYS_PORT_D_TRIS ^ 0xFFFF);
9D000178  00002021   ADDU A0, ZERO, ZERO
9D00017C  24050003   ADDIU A1, ZERO, 3
9D000180  3406F3FF   ORI A2, ZERO, -3073
9D000184  0F400B8A   JAL 0x9D002E28
9D000188  00000000   NOP
83:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_D);
9D00018C  00002021   ADDU A0, ZERO, ZERO
9D000190  24050003   ADDIU A1, ZERO, 3
9D000194  0F400BBC   JAL 0x9D002EF0
9D000198  00000000   NOP
84:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
9D00019C  00002021   ADDU A0, ZERO, ZERO
9D0001A0  24050003   ADDIU A1, ZERO, 3
9D0001A4  3406FFFF   ORI A2, ZERO, -1
9D0001A8  24070001   ADDIU A3, ZERO, 1
9D0001AC  0F400924   JAL 0x9D002490
9D0001B0  00000000   NOP
85:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_CNEN);
9D0001B4  00002021   ADDU A0, ZERO, ZERO
9D0001B8  24050003   ADDIU A1, ZERO, 3
9D0001BC  00003021   ADDU A2, ZERO, ZERO
9D0001C0  0F400BB2   JAL 0x9D002EC8
9D0001C4  00000000   NOP
86:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_CNPU);
9D0001C8  00002021   ADDU A0, ZERO, ZERO
9D0001CC  24050003   ADDIU A1, ZERO, 3
9D0001D0  00003021   ADDU A2, ZERO, ZERO
9D0001D4  0F400BA8   JAL 0x9D002EA0
9D0001D8  00000000   NOP
87:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_CNPD);
9D0001DC  00002021   ADDU A0, ZERO, ZERO
9D0001E0  24050003   ADDIU A1, ZERO, 3
9D0001E4  00003021   ADDU A2, ZERO, ZERO
9D0001E8  0F400B9E   JAL 0x9D002E78
9D0001EC  00000000   NOP
88:                      
89:                      /* PORT E Initialization */
90:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_ODC);
9D0001F0  00002021   ADDU A0, ZERO, ZERO
9D0001F4  24050004   ADDIU A1, ZERO, 4
9D0001F8  00003021   ADDU A2, ZERO, ZERO
9D0001FC  0F400B94   JAL 0x9D002E50
9D000200  00000000   NOP
91:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_E,  SYS_PORT_E_LAT);
9D000204  00002021   ADDU A0, ZERO, ZERO
9D000208  24050004   ADDIU A1, ZERO, 4
9D00020C  00003021   ADDU A2, ZERO, ZERO
9D000210  0F400BC6   JAL 0x9D002F18
9D000214  00000000   NOP
92:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_E,  SYS_PORT_E_TRIS ^ 0xFFFF);
9D000218  00002021   ADDU A0, ZERO, ZERO
9D00021C  24050004   ADDIU A1, ZERO, 4
9D000220  3406FFFF   ORI A2, ZERO, -1
9D000224  0F400B8A   JAL 0x9D002E28
9D000228  00000000   NOP
93:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_E);
9D00022C  00002021   ADDU A0, ZERO, ZERO
9D000230  24050004   ADDIU A1, ZERO, 4
9D000234  0F400BBC   JAL 0x9D002EF0
9D000238  00000000   NOP
94:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
9D00023C  00002021   ADDU A0, ZERO, ZERO
9D000240  24050004   ADDIU A1, ZERO, 4
9D000244  3406FFFF   ORI A2, ZERO, -1
9D000248  24070001   ADDIU A3, ZERO, 1
9D00024C  0F400924   JAL 0x9D002490
9D000250  00000000   NOP
95:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_CNEN);
9D000254  00002021   ADDU A0, ZERO, ZERO
9D000258  24050004   ADDIU A1, ZERO, 4
9D00025C  00003021   ADDU A2, ZERO, ZERO
9D000260  0F400BB2   JAL 0x9D002EC8
9D000264  00000000   NOP
96:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_CNPU);
9D000268  00002021   ADDU A0, ZERO, ZERO
9D00026C  24050004   ADDIU A1, ZERO, 4
9D000270  00003021   ADDU A2, ZERO, ZERO
9D000274  0F400BA8   JAL 0x9D002EA0
9D000278  00000000   NOP
97:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_CNPD);
9D00027C  00002021   ADDU A0, ZERO, ZERO
9D000280  24050004   ADDIU A1, ZERO, 4
9D000284  00003021   ADDU A2, ZERO, ZERO
9D000288  0F400B9E   JAL 0x9D002E78
9D00028C  00000000   NOP
98:                      
99:                      /* PORT F Initialization */
100:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_ODC);
9D000290  00002021   ADDU A0, ZERO, ZERO
9D000294  24050005   ADDIU A1, ZERO, 5
9D000298  00003021   ADDU A2, ZERO, ZERO
9D00029C  0F400B94   JAL 0x9D002E50
9D0002A0  00000000   NOP
101:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_F,  SYS_PORT_F_LAT);
9D0002A4  00002021   ADDU A0, ZERO, ZERO
9D0002A8  24050005   ADDIU A1, ZERO, 5
9D0002AC  00003021   ADDU A2, ZERO, ZERO
9D0002B0  0F400BC6   JAL 0x9D002F18
9D0002B4  00000000   NOP
102:                     PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_F,  SYS_PORT_F_TRIS ^ 0xFFFF);
9D0002B8  00002021   ADDU A0, ZERO, ZERO
9D0002BC  24050005   ADDIU A1, ZERO, 5
9D0002C0  3406FF83   ORI A2, ZERO, -125
9D0002C4  0F400B8A   JAL 0x9D002E28
9D0002C8  00000000   NOP
103:                     PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_F);
9D0002CC  00002021   ADDU A0, ZERO, ZERO
9D0002D0  24050005   ADDIU A1, ZERO, 5
9D0002D4  0F400BBC   JAL 0x9D002EF0
9D0002D8  00000000   NOP
104:                     PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
9D0002DC  00002021   ADDU A0, ZERO, ZERO
9D0002E0  24050005   ADDIU A1, ZERO, 5
9D0002E4  3406FFFF   ORI A2, ZERO, -1
9D0002E8  24070001   ADDIU A3, ZERO, 1
9D0002EC  0F400924   JAL 0x9D002490
9D0002F0  00000000   NOP
105:                     PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_CNEN);
9D0002F4  00002021   ADDU A0, ZERO, ZERO
9D0002F8  24050005   ADDIU A1, ZERO, 5
9D0002FC  00003021   ADDU A2, ZERO, ZERO
9D000300  0F400BB2   JAL 0x9D002EC8
9D000304  00000000   NOP
106:                     PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_CNPU);
9D000308  00002021   ADDU A0, ZERO, ZERO
9D00030C  24050005   ADDIU A1, ZERO, 5
9D000310  00003021   ADDU A2, ZERO, ZERO
9D000314  0F400BA8   JAL 0x9D002EA0
9D000318  00000000   NOP
107:                     PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_CNPD);
9D00031C  00002021   ADDU A0, ZERO, ZERO
9D000320  24050005   ADDIU A1, ZERO, 5
9D000324  00003021   ADDU A2, ZERO, ZERO
9D000328  0F400B9E   JAL 0x9D002E78
9D00032C  00000000   NOP
108:                 
109:                     /* PPS Input Remapping */
110:                     PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_U1RX, INPUT_PIN_RPD10 );
9D000330  00002021   ADDU A0, ZERO, ZERO
9D000334  24050013   ADDIU A1, ZERO, 19
9D000338  24060003   ADDIU A2, ZERO, 3
9D00033C  0F4002D1   JAL 0x9D000B44
9D000340  00000000   NOP
111:                 
112:                     /* PPS Output Remapping */
113:                     PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_U1TX, OUTPUT_PIN_RPD11 );
9D000344  00002021   ADDU A0, ZERO, ZERO
9D000348  24050003   ADDIU A1, ZERO, 3
9D00034C  2406002D   ADDIU A2, ZERO, 45
9D000350  0F400A49   JAL 0x9D002924
9D000354  00000000   NOP
114:                 
115:                     
116:                 }
9D000358  03C0E821   ADDU SP, S8, ZERO
9D00035C  8FBF0014   LW RA, 20(SP)
9D000360  8FBE0010   LW S8, 16(SP)
9D000364  27BD0018   ADDIU SP, SP, 24
9D000368  03E00008   JR RA
9D00036C  00000000   NOP
117:                 
118:                 
119:                 /*******************************************************************************
120:                  End of File
121:                 */
---  /home/david/microchip/harmony/projects/einkdisplay/firmware/src/system_config/default/framework/system/clk/src/sys_clk_static.c
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_clk_static.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the oscillators
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Clock System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                      
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  //DOM-IGNORE-END
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include "system_config.h"
59:                  #include "system_definitions.h"
60:                  #include "peripheral/osc/plib_osc.h"
61:                  
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  // Section: File Scope Functions
65:                  // *****************************************************************************
66:                  // *****************************************************************************
67:                  
68:                  // *****************************************************************************
69:                  /* Function:
70:                      void SYS_CLK_Static_Initialize ( const SYS_CLK_INIT const * clkInit )
71:                  
72:                    Summary:
73:                      Initializes hardware and internal data structure of the System Clock.
74:                  
75:                    Description:
76:                      This function initializes the hardware and internal data structure of System
77:                      Clock Service.
78:                  
79:                    Remarks:
80:                      This is configuration values for the static version of the Clock System Service 
81:                      module is determined by the user via the Microchip Harmony Configurator GUI.
82:                      This template will build a sys_clk_static.h and sys_clk_static.c file with 
83:                      the configuration per the user's choice.
84:                  
85:                      The objective is to eliminate the user's need to be knowledgeable in the function of
86:                      the 'configuration bits' to configure the system oscillators. 
87:                  */
88:                  
89:                  void SYS_CLK_Initialize( const SYS_CLK_INIT const * clkInit )
90:                  {
9D001A94  27BDFFE8   ADDIU SP, SP, -24
9D001A98  AFBF0014   SW RA, 20(SP)
9D001A9C  AFBE0010   SW S8, 16(SP)
9D001AA0  03A0F021   ADDU S8, SP, ZERO
9D001AA4  AFC40018   SW A0, 24(S8)
91:                      SYS_DEVCON_SystemUnlock ( );
9D001AA8  0F4007C3   JAL SYS_DEVCON_SystemUnlock
9D001AAC  00000000   NOP
92:                      
93:                      PLIB_OSC_FRCDivisorSelect( OSC_ID_0, OSC_FRC_DIV_2);
9D001AB0  00002021   ADDU A0, ZERO, ZERO
9D001AB4  24050001   ADDIU A1, ZERO, 1
9D001AB8  0F400A7F   JAL 0x9D0029FC
9D001ABC  00000000   NOP
94:                  
95:                      /* Enable Peripheral Bus 1 */
96:                      PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 0, 1 );
9D001AC0  00002021   ADDU A0, ZERO, ZERO
9D001AC4  00002821   ADDU A1, ZERO, ZERO
9D001AC8  24060001   ADDIU A2, ZERO, 1
9D001ACC  0F40071D   JAL 0x9D001C74
9D001AD0  00000000   NOP
97:                  
98:                  
99:                  
100:                 
101:                 
102:                 
103:                     /* Disable REFCLKO1*/
104:                     PLIB_OSC_ReferenceOscDisable ( OSC_ID_0, OSC_REFERENCE_1 );
9D001AD4  00002021   ADDU A0, ZERO, ZERO
9D001AD8  00002821   ADDU A1, ZERO, ZERO
9D001ADC  0F400BF3   JAL 0x9D002FCC
9D001AE0  00000000   NOP
105:                     /* Disable REFCLK1_OE*/
106:                     PLIB_OSC_ReferenceOutputDisable ( OSC_ID_0, OSC_REFERENCE_1 );
9D001AE4  00002021   ADDU A0, ZERO, ZERO
9D001AE8  00002821   ADDU A1, ZERO, ZERO
9D001AEC  0F400BEC   JAL 0x9D002FB0
9D001AF0  00000000   NOP
107:                 
108:                     SYS_DEVCON_SystemLock ( );
9D001AF4  0F4007DD   JAL SYS_DEVCON_SystemLock
9D001AF8  00000000   NOP
109:                 }
9D001AFC  03C0E821   ADDU SP, S8, ZERO
9D001B00  8FBF0014   LW RA, 20(SP)
9D001B04  8FBE0010   LW S8, 16(SP)
9D001B08  27BD0018   ADDIU SP, SP, 24
9D001B0C  03E00008   JR RA
9D001B10  00000000   NOP
110:                 
111:                 //******************************************************************************
112:                 /* Function:
113:                     inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
114:                 
115:                   Summary:
116:                     Gets the system clock frequency in Hertz.
117:                 
118:                   Description:
119:                     This function gets the System clock frequency in Hertz.
120:                 
121:                   Precondition:
122:                     None.
123:                 
124:                   Parameters:
125:                     None.
126:                 
127:                   Returns:
128:                     System clock frequency in Hertz.
129:                 
130:                   Example:
131:                     <code>
132:                     uint32_t sysClockHz;
133:                 
134:                     sysClockHz = SYS_CLK_SystemFrequencyGet ( );
135:                     </code>
136:                 
137:                   Remarks:
138:                  */
139:                 
140:                 inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
141:                 {
9D002D88  27BDFFF8   ADDIU SP, SP, -8
9D002D8C  AFBE0004   SW S8, 4(SP)
9D002D90  03A0F021   ADDU S8, SP, ZERO
142:                     return SYS_CLK_FREQ;
9D002D94  3C0204C4   LUI V0, 1220
9D002D98  3442B400   ORI V0, V0, -19456
143:                 }
9D002D9C  03C0E821   ADDU SP, S8, ZERO
9D002DA0  8FBE0004   LW S8, 4(SP)
9D002DA4  27BD0008   ADDIU SP, SP, 8
9D002DA8  03E00008   JR RA
9D002DAC  00000000   NOP
144:                 
145:                 //******************************************************************************
146:                 /* Function:
147:                     inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
148:                 
149:                   Summary:
150:                     Gets the selected clock peripheral bus frequency in Hertz.
151:                 
152:                   Description:
153:                     This function gets the selected peripheral bus clock frequency in Hertz.
154:                 
155:                   Precondition:
156:                     None.
157:                 
158:                   Parameters:
159:                 	peripheralBus - Reference clock bus selection. One of the possible value from
160:                 				CLK_BUSES_PERIPHERAL enum. For devices that do not have multiple
161:                 				clock channels for Reference clock, CLK_BUS_PERIPHERAL_1 should be
162:                 				the selection.
163:                 
164:                   Returns:
165:                     Clock frequency in Hertz.
166:                 
167:                   Example:
168:                     <code>
169:                     unsigned long peripheralClockHz;
170:                 
171:                     peripheralClockHz = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_5 );
172:                     </code>
173:                 
174:                   Remarks:
175:                 	Most of the devices doesn't have multiple Peripheral clock buses. In that case, 
176:                 	pass CLK_USB_PERIPHERAL_1 as the bus number.
177:                  */
178:                 
179:                 inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
180:                 {
9D002B20  27BDFFF8   ADDIU SP, SP, -8
9D002B24  AFBE0004   SW S8, 4(SP)
9D002B28  03A0F021   ADDU S8, SP, ZERO
9D002B2C  AFC40008   SW A0, 8(S8)
181:                     return SYS_CLK_BUS_PERIPHERAL_1;
9D002B30  3C0204C4   LUI V0, 1220
9D002B34  3442B400   ORI V0, V0, -19456
182:                 }
9D002B38  03C0E821   ADDU SP, S8, ZERO
9D002B3C  8FBE0004   LW S8, 4(SP)
9D002B40  27BD0008   ADDIU SP, SP, 8
9D002B44  03E00008   JR RA
9D002B48  00000000   NOP
183:                 
184:                 
185:                 //******************************************************************************
186:                 /* Function:
187:                     inline uint32_t SYS_CLK_ReferenceClockFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
188:                 
189:                   Summary:
190:                     Gets the selected Reference clock bus frequency in Hertz.
191:                 
192:                   Description:
193:                     This function gets frequency of the selected Reference clock bus in Hertz.
194:                 
195:                   Precondition:
196:                     None.
197:                 
198:                   Parameters:
199:                 	peripheralBus - Reference clock bus selection. One of the possible value from
200:                 				CLK_BUSES_REFERENCE enum. For devices that do not have multiple
201:                 				clock channels for Reference clock, CLK_BUS_REFERENCE_1 should be
202:                 				the selection.
203:                 
204:                   Returns:
205:                     Clock frequency in Hz.
206:                 
207:                   Example:
208:                     <code>
209:                     unsigned long sysClockOutputHz;
210:                 
211:                     sysClockOutputHz = SYS_CLK_ReferenceClockFrequencyGet ( CLK_BUS_REFERENCE_3 );
212:                     </code>
213:                 
214:                   Remarks:
215:                  */
216:                 
217:                 inline uint32_t SYS_CLK_ReferenceClockFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
218:                 {
00000000  00000000   NOP
219:                 	return 0;
00000010  00000000   NOP
220:                 }
00000014  00000000   NOP
---  /home/david/microchip/harmony/projects/einkdisplay/firmware/src/system_config/default/framework/driver/usart/drv_usart_static.c
1:                   /*******************************************************************************
2:                     USART Driver Functions for Static Single Instance Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart_static.c
9:                   
10:                    Summary:
11:                      USART driver impementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The USART device driver provides a simple interface to manage the USART
15:                      modules on Microchip microcontrollers. This file contains implemenation
16:                      for the USART driver.
17:                      
18:                    Remarks:
19:                      Static interfaces incorporate the driver instance number within the names
20:                      of the routines, eliminating the need for an object ID or object handle.
21:                      
22:                      Static single-open interfaces also eliminate the need for the open handle.
23:                  *******************************************************************************/
24:                  
25:                  //DOM-IGNORE-BEGIN
26:                  /*******************************************************************************
27:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
28:                  
29:                  Microchip licenses to you the right to use, modify, copy and distribute
30:                  Software only when embedded on a Microchip microcontroller or digital signal
31:                  controller that is integrated into your product or third party product
32:                  (pursuant to the sublicense terms in the accompanying license agreement).
33:                  
34:                  You should refer to the license agreement accompanying this Software for
35:                  additional information regarding your rights and obligations.
36:                  
37:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
38:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
39:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
40:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
41:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
42:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
43:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
44:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
45:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
46:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
47:                  *******************************************************************************/
48:                  //DOM-IGNORE-END
49:                  
50:                  #include "system_config.h"
51:                  #include "peripheral/usart/plib_usart.h"
52:                  #include "peripheral/int/plib_int.h"
53:                  #include "system_definitions.h"
54:                   
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Instance 0 static driver functions
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  
62:                  void DRV_USART0_Initialize(void)
63:                  {
9D001378  27BDFFE8   ADDIU SP, SP, -24
9D00137C  AFBF0014   SW RA, 20(SP)
9D001380  AFBE0010   SW S8, 16(SP)
9D001384  03A0F021   ADDU S8, SP, ZERO
64:                      /* Initialize USART */
65:                      PLIB_USART_BaudRateSet(USART_ID_1, SYS_CLK_PeripheralFrequencyGet(CLK_BUS_PERIPHERAL_1), 9600);
9D001388  00002021   ADDU A0, ZERO, ZERO
9D00138C  0F400AC8   JAL SYS_CLK_PeripheralFrequencyGet
9D001390  00000000   NOP
9D001394  00002021   ADDU A0, ZERO, ZERO
9D001398  00402821   ADDU A1, V0, ZERO
9D00139C  24062580   ADDIU A2, ZERO, 9600
9D0013A0  0F400443   JAL 0x9D00110C
9D0013A4  00000000   NOP
66:                      PLIB_USART_HandshakeModeSelect(USART_ID_1, USART_HANDSHAKE_MODE_SIMPLEX);
9D0013A8  00002021   ADDU A0, ZERO, ZERO
9D0013AC  24050001   ADDIU A1, ZERO, 1
9D0013B0  0F400478   JAL 0x9D0011E0
9D0013B4  00000000   NOP
67:                      PLIB_USART_OperationModeSelect(USART_ID_1, USART_ENABLE_TX_RX_CTS_RTS_USED);
9D0013B8  00002021   ADDU A0, ZERO, ZERO
9D0013BC  24050002   ADDIU A1, ZERO, 2
9D0013C0  0F40050D   JAL 0x9D001434
9D0013C4  00000000   NOP
68:                      PLIB_USART_LineControlModeSelect(USART_ID_1, USART_8N1);
9D0013C8  00002021   ADDU A0, ZERO, ZERO
9D0013CC  00002821   ADDU A1, ZERO, ZERO
9D0013D0  0F400231   JAL 0x9D0008C4
9D0013D4  00000000   NOP
69:                      PLIB_USART_TransmitterEnable(USART_ID_1);
9D0013D8  00002021   ADDU A0, ZERO, ZERO
9D0013DC  0F400771   JAL 0x9D001DC4
9D0013E0  00000000   NOP
70:                      PLIB_USART_TransmitterInterruptModeSelect(USART_ID_1, USART_TRANSMIT_FIFO_NOT_FULL);
9D0013E4  00002021   ADDU A0, ZERO, ZERO
9D0013E8  00002821   ADDU A1, ZERO, ZERO
9D0013EC  0F4004AB   JAL 0x9D0012AC
9D0013F0  00000000   NOP
71:                      PLIB_USART_ReceiverEnable(USART_ID_1);
9D0013F4  00002021   ADDU A0, ZERO, ZERO
9D0013F8  0F400755   JAL 0x9D001D54
9D0013FC  00000000   NOP
72:                      PLIB_USART_ReceiverInterruptModeSelect(USART_ID_1, USART_RECEIVE_FIFO_ONE_CHAR);
9D001400  00002021   ADDU A0, ZERO, ZERO
9D001404  00002821   ADDU A1, ZERO, ZERO
9D001408  0F40053C   JAL 0x9D0014F0
9D00140C  00000000   NOP
73:                  
74:                      PLIB_USART_Enable(USART_ID_1);
9D001410  00002021   ADDU A0, ZERO, ZERO
9D001414  0F400739   JAL 0x9D001CE4
9D001418  00000000   NOP
75:                  }
9D00141C  03C0E821   ADDU SP, S8, ZERO
9D001420  8FBF0014   LW RA, 20(SP)
9D001424  8FBE0010   LW S8, 16(SP)
9D001428  27BD0018   ADDIU SP, SP, 24
9D00142C  03E00008   JR RA
9D001430  00000000   NOP
76:                  
77:                  bool DRV_USART0_ReceiverBufferIsEmpty(void)
78:                  {
00000000  00000000   NOP
79:                     return (!PLIB_USART_ReceiverDataIsAvailable(USART_ID_1));
00000010  00000000   NOP
80:                  }
00000034  00000000   NOP
81:                  
82:                  uint8_t DRV_USART0_ReadByte(void)
83:                  {
00000000  00000000   NOP
84:                     if(PLIB_USART_ReceiverOverrunHasOccurred(USART_ID_1))
00000010  00000000   NOP
85:                     {
86:                        PLIB_USART_ReceiverOverrunErrorClear(USART_ID_1);
00000024  00000000   NOP
87:                     }
88:                  
89:                     return (PLIB_USART_ReceiverByteReceive(USART_ID_1));
00000030  00000000   NOP
90:                  }
00000040  00000000   NOP
91:                  
92:                  void DRV_USART0_WriteByte(const uint8_t byte)
93:                  {
00000000  00000000   NOP
94:                     while(PLIB_USART_TransmitterBufferIsFull(USART_ID_1))
00000018  00000000   NOP
95:                     {
96:                     }
97:                  
98:                     PLIB_USART_TransmitterByteSend(USART_ID_1, byte);
00000030  00000000   NOP
99:                  }
00000044  00000000   NOP
100:                 
101:                 
102:                 /*******************************************************************************
103:                  End of File
104:                 */
---  /home/david/microchip/harmony/projects/einkdisplay/firmware/src/system_config/default/framework/driver/tmr/src/drv_tmr_static.c
1:                   /*******************************************************************************
2:                     Timer Static Driver File
3:                   
4:                     File Name:
5:                       drv_tmr_static.c
6:                   
7:                     Company:
8:                       Microchip Technology Inc.	
9:                   
10:                    Summary:
11:                      Timer driver implementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer
15:                      modules on Microchip microcontrollers.
16:                      
17:                    Remarks:
18:                      None
19:                   *******************************************************************************/
20:                  
21:                  /*******************************************************************************
22:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Mirochip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a MTMRrochip mTMRrocontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublTMRense terms in the accompanying lTMRense agreement).
28:                  
29:                  You should refer to the lTMRense agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTTMRULAR PURPOSE.
35:                  IN NO EVENT SHALL MTMRROCHIP OR ITS LTMRENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRTMRT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVTMRES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                   *******************************************************************************/
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Header Includes
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  #include "framework/driver/tmr/drv_tmr_static.h"
50:                  
51:                   // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Instance 0 static driver functions
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  void DRV_TMR0_Initialize(void)
57:                  {	
9D001B14  27BDFFE8   ADDIU SP, SP, -24
9D001B18  AFBF0014   SW RA, 20(SP)
9D001B1C  AFBE0010   SW S8, 16(SP)
9D001B20  03A0F021   ADDU S8, SP, ZERO
58:                      /* Initialize Timer Instance0 */
59:                      /* Disable Timer */
60:                      PLIB_TMR_Stop(TMR_ID_1);
9D001B24  00002021   ADDU A0, ZERO, ZERO
9D001B28  0F400616   JAL 0x9D001858
9D001B2C  00000000   NOP
61:                      /* Select clock source */
62:                      PLIB_TMR_ClockSourceSelect(TMR_ID_1, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK);
9D001B30  00002021   ADDU A0, ZERO, ZERO
9D001B34  00002821   ADDU A1, ZERO, ZERO
9D001B38  0F4001D8   JAL 0x9D000760
9D001B3C  00000000   NOP
63:                      /* Select prescalar value */
64:                      PLIB_TMR_PrescaleSelect(TMR_ID_1, TMR_PRESCALE_VALUE_1);
9D001B40  00002021   ADDU A0, ZERO, ZERO
9D001B44  00002821   ADDU A1, ZERO, ZERO
9D001B48  0F40017C   JAL 0x9D0005F0
9D001B4C  00000000   NOP
65:                      /* Enable 16 bit mode */
66:                      PLIB_TMR_Mode16BitEnable(TMR_ID_1);
9D001B50  00002021   ADDU A0, ZERO, ZERO
9D001B54  0F400A0C   JAL 0x9D002830
9D001B58  00000000   NOP
67:                      /* Clear counter */	
68:                      PLIB_TMR_Counter16BitClear(TMR_ID_1);
9D001B5C  00002021   ADDU A0, ZERO, ZERO
9D001B60  0F400683   JAL 0x9D001A0C
9D001B64  00000000   NOP
69:                      /*Set period */	
70:                      PLIB_TMR_Period16BitSet(TMR_ID_1, 12000);
9D001B68  00002021   ADDU A0, ZERO, ZERO
9D001B6C  24052EE0   ADDIU A1, ZERO, 12000
9D001B70  0F400660   JAL 0x9D001980
9D001B74  00000000   NOP
71:                  
72:                  }
9D001B78  03C0E821   ADDU SP, S8, ZERO
9D001B7C  8FBF0014   LW RA, 20(SP)
9D001B80  8FBE0010   LW S8, 16(SP)
9D001B84  27BD0018   ADDIU SP, SP, 24
9D001B88  03E00008   JR RA
9D001B8C  00000000   NOP
73:                  
74:                  inline void DRV_TMR0_Start(void)
75:                  {
9D002994  27BDFFE8   ADDIU SP, SP, -24
9D002998  AFBF0014   SW RA, 20(SP)
9D00299C  AFBE0010   SW S8, 16(SP)
9D0029A0  03A0F021   ADDU S8, SP, ZERO
76:                      /* Start Timer*/
77:                      PLIB_TMR_Start(TMR_ID_1);
9D0029A4  00002021   ADDU A0, ZERO, ZERO
9D0029A8  0F4005EF   JAL 0x9D0017BC
9D0029AC  00000000   NOP
78:                  }
9D0029B0  03C0E821   ADDU SP, S8, ZERO
9D0029B4  8FBF0014   LW RA, 20(SP)
9D0029B8  8FBE0010   LW S8, 16(SP)
9D0029BC  27BD0018   ADDIU SP, SP, 24
9D0029C0  03E00008   JR RA
9D0029C4  00000000   NOP
79:                  
80:                  inline void DRV_TMR0_Stop(void)
81:                  {
00000000  00000000   NOP
82:                      /* Stop Timer*/
83:                      PLIB_TMR_Stop(TMR_ID_1);
00000010  00000000   NOP
84:                  }
0000001C  00000000   NOP
85:                  
86:                  inline void DRV_TMR0_CounterClear(void)
87:                  {
00000000  00000000   NOP
88:                      /* Clear 16-bit counter value */
89:                      PLIB_TMR_Counter16BitClear(TMR_ID_1);    
00000010  00000000   NOP
90:                  }
0000001C  00000000   NOP
91:                  
92:                  void DRV_TMR0_CounterValueSet(uint32_t value)
93:                  {
00000000  00000000   NOP
94:                      /* Set 16-bit counter value*/
95:                      PLIB_TMR_Counter16BitSet(TMR_ID_1, (uint16_t)value);
00000014  00000000   NOP
96:                  }
0000002C  00000000   NOP
97:                  
98:                  uint32_t DRV_TMR0_CounterValueGet(void)
99:                  {
00000000  00000000   NOP
100:                     /* Get 16-bit counter value*/
101:                     return (uint32_t) PLIB_TMR_Counter16BitGet(TMR_ID_1);
00000010  00000000   NOP
102:                 }
0000001C  00000000   NOP
103:                 
104:                  
105:                  
106:                 /*******************************************************************************
107:                  End of File
108:                 */
---  /home/david/microchip/harmony/projects/einkdisplay/firmware/src/system_config/default/framework/driver/adc/src/drv_adc_static.c
1:                   /*******************************************************************************
2:                     ADC Driver Initialization File
3:                   
4:                     File Name:
5:                       drv_adc_static.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the ADC driver.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "DRV_ADC_Initialize" function, configuration bits, and allocates
13:                      any necessary global system resources, such as the systemObjects structure
14:                      that contains the object handles to all the MPLAB Harmony module objects in
15:                      the system.
16:                   *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
20:                  
21:                  Microchip licenses to you the right to use, modify, copy and distribute
22:                  Software only when embedded on a Microchip microcontroller or digital signal
23:                  controller that is integrated into your product or third party product
24:                  (pursuant to the sublicense terms in the accompanying license agreement).
25:                  
26:                  You should refer to the license agreement accompanying this Software for
27:                  additional information regarding your rights and obligations.
28:                  
29:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
30:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
31:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
32:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
33:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
34:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
35:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
36:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
37:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
38:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
39:                   *******************************************************************************/
40:                  
41:                  // *****************************************************************************
42:                  // *****************************************************************************
43:                  // Section: Include Files
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  #include "framework/driver/adc/drv_adc_static.h"
47:                   
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Section: ADC Static Driver Functions
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  void DRV_ADC_Initialize(void)
54:                  {
9D000D90  27BDFFE8   ADDIU SP, SP, -24
9D000D94  AFBF0014   SW RA, 20(SP)
9D000D98  AFBE0010   SW S8, 16(SP)
9D000D9C  03A0F021   ADDU S8, SP, ZERO
55:                      /* Select Clock Source */
56:                      PLIB_ADC_ConversionClockSourceSelect(DRV_ADC_ID_1, ADC_CLOCK_SOURCE_SYSTEM_CLOCK);
9D000DA0  00002021   ADDU A0, ZERO, ZERO
9D000DA4  00002821   ADDU A1, ZERO, ZERO
9D000DA8  0F400AB0   JAL 0x9D002AC0
9D000DAC  00000000   NOP
57:                      /* Select Clock Prescaler */
58:                      PLIB_ADC_ConversionClockSet(DRV_ADC_ID_1, SYS_CLK_FREQ, 320000000);
9D000DB0  00002021   ADDU A0, ZERO, ZERO
9D000DB4  3C0204C4   LUI V0, 1220
9D000DB8  3445B400   ORI A1, V0, -19456
9D000DBC  3C021312   LUI V0, 4882
9D000DC0  3446D000   ORI A2, V0, -12288
9D000DC4  0F400A3A   JAL 0x9D0028E8
9D000DC8  00000000   NOP
59:                  
60:                      /* Select Power Mode */
61:                      PLIB_ADC_StopInIdleDisable(DRV_ADC_ID_1);
9D000DCC  00002021   ADDU A0, ZERO, ZERO
9D000DD0  0F400BD7   JAL 0x9D002F5C
9D000DD4  00000000   NOP
62:                  	
63:                      /* Select Voltage Reference */
64:                      PLIB_ADC_VoltageReferenceSelect(DRV_ADC_ID_1, ADC_REFERENCE_VDD_TO_AVSS);
9D000DD8  00002021   ADDU A0, ZERO, ZERO
9D000DDC  00002821   ADDU A1, ZERO, ZERO
9D000DE0  0F400AA4   JAL 0x9D002A90
9D000DE4  00000000   NOP
65:                  
66:                      /* Sampling Selections */
67:                      /* Select Sampling Mode */
68:                      PLIB_ADC_SamplingModeSelect(DRV_ADC_ID_1, ADC_SAMPLING_MODE_MUXA);
9D000DE8  00002021   ADDU A0, ZERO, ZERO
9D000DEC  00002821   ADDU A1, ZERO, ZERO
9D000DF0  0F400B76   JAL 0x9D002DD8
9D000DF4  00000000   NOP
69:                      /* Number of Samples Per Interrupt */
70:                      PLIB_ADC_SamplesPerInterruptSelect(DRV_ADC_ID_1, ADC_16SAMPLES_PER_INTERRUPT);
9D000DF8  00002021   ADDU A0, ZERO, ZERO
9D000DFC  2405000F   ADDIU A1, ZERO, 15
9D000E00  0F400ADE   JAL 0x9D002B78
9D000E04  00000000   NOP
71:                  
72:                      /* Conversion Selections */
73:                      /* Select Trigger Source */
74:                      PLIB_ADC_ConversionTriggerSourceSelect(DRV_ADC_ID_1, ADC_CONVERSION_TRIGGER_INTERNAL_COUNT);
9D000E08  00002021   ADDU A0, ZERO, ZERO
9D000E0C  24050007   ADDIU A1, ZERO, 7
9D000E10  0F400AE9   JAL 0x9D002BA4
9D000E14  00000000   NOP
75:                      /* Select Result Format */
76:                      PLIB_ADC_ResultFormatSelect(DRV_ADC_ID_1, ADC_RESULT_FORMAT_INTEGER_16BIT);
9D000E18  00002021   ADDU A0, ZERO, ZERO
9D000E1C  00002821   ADDU A1, ZERO, ZERO
9D000E20  0F400AF4   JAL 0x9D002BD0
9D000E24  00000000   NOP
77:                      /* Buffer Mode */
78:                      PLIB_ADC_ResultBufferModeSelect(DRV_ADC_ID_1, ADC_BUFFER_MODE_ONE_16WORD_BUFFER);
9D000E28  00002021   ADDU A0, ZERO, ZERO
9D000E2C  00002821   ADDU A1, ZERO, ZERO
9D000E30  0F400AFF   JAL 0x9D002BFC
9D000E34  00000000   NOP
79:                  
80:                      /* Channel Selections */
81:                      /* MUX A Negative Input Select */
82:                      PLIB_ADC_MuxChannel0InputNegativeSelect(DRV_ADC_ID_1, ADC_MUX_A, ADC_INPUT_NEGATIVE_VREF_MINUS);
9D000E38  00002021   ADDU A0, ZERO, ZERO
9D000E3C  00002821   ADDU A1, ZERO, ZERO
9D000E40  00003021   ADDU A2, ZERO, ZERO
9D000E44  0F400868   JAL 0x9D0021A0
9D000E48  00000000   NOP
83:                   
84:                  
85:                      /* MUX A Positive Input Select */
86:                      PLIB_ADC_MuxChannel0InputPositiveSelect(DRV_ADC_ID_1, ADC_MUX_A, ADC_INPUT_POSITIVE_AN2);
9D000E4C  00002021   ADDU A0, ZERO, ZERO
9D000E50  00002821   ADDU A1, ZERO, ZERO
9D000E54  24060002   ADDIU A2, ZERO, 2
9D000E58  0F4007F7   JAL 0x9D001FDC
9D000E5C  00000000   NOP
87:                   
88:                  }
9D000E60  03C0E821   ADDU SP, S8, ZERO
9D000E64  8FBF0014   LW RA, 20(SP)
9D000E68  8FBE0010   LW S8, 16(SP)
9D000E6C  27BD0018   ADDIU SP, SP, 24
9D000E70  03E00008   JR RA
9D000E74  00000000   NOP
89:                  
90:                  inline void DRV_ADC_DeInitialize(void)
91:                  {
00000000  00000000   NOP
92:                      /* Disable ADC */
93:                      PLIB_ADC_Disable(DRV_ADC_ID_1);
00000010  00000000   NOP
94:                  }
0000001C  00000000   NOP
95:                  
96:                  inline void DRV_ADC_Open(void)
97:                  {
00000000  00000000   NOP
98:                      /* Enable ADC */
99:                      PLIB_ADC_Enable(DRV_ADC_ID_1);
00000010  00000000   NOP
100:                 }
0000001C  00000000   NOP
101:                 
102:                 inline void DRV_ADC_Close(void)
103:                 {
00000000  00000000   NOP
104:                     /* Disable ADC */
105:                     PLIB_ADC_Disable(DRV_ADC_ID_1);
00000010  00000000   NOP
106:                 }
0000001C  00000000   NOP
107:                 
108:                 inline void DRV_ADC_Start(void)
109:                 {
00000000  00000000   NOP
110:                     /* Start ADC */
111:                     PLIB_ADC_SamplingStart(DRV_ADC_ID_1);
00000010  00000000   NOP
112:                 }
0000001C  00000000   NOP
113:                 
114:                 inline void DRV_ADC_Stop(void)
115:                 {
00000000  00000000   NOP
116:                     /* Stop ADC */
117:                     PLIB_ADC_SamplingStop(DRV_ADC_ID_1);	
00000010  00000000   NOP
118:                 }
0000001C  00000000   NOP
119:                 
120:                 inline void DRV_ADC_NegativeInputSelect(DRV_ADC_MUX mux, DRV_ADC_INPUTS_NEGATIVE input)
121:                 {
00000000  00000000   NOP
122:                     /* Select Negative Input */
123:                     PLIB_ADC_MuxChannel0InputNegativeSelect(DRV_ADC_ID_1, mux, input);
00000018  00000000   NOP
124:                 }
0000002C  00000000   NOP
125:                 
126:                 inline void DRV_ADC_PositiveInputSelect(DRV_ADC_MUX mux, DRV_ADC_INPUTS_POSITIVE input)
127:                 {
00000000  00000000   NOP
128:                     /* Select Positive Input */
129:                     PLIB_ADC_MuxChannel0InputPositiveSelect(DRV_ADC_ID_1, mux, input);
00000018  00000000   NOP
130:                 }
0000002C  00000000   NOP
131:                 
132:                 inline void DRV_ADC_ChannelScanInputsAdd(DRV_ADC_INPUTS_SCAN scanInput)
133:                 {
00000000  00000000   NOP
134:                     /* Add Scan Input */
135:                     PLIB_ADC_InputScanMaskAdd(DRV_ADC_ID_1, scanInput);
00000014  00000000   NOP
136:                 }
00000024  00000000   NOP
137:                 
138:                 inline void DRV_ADC_ChannelScanInputsRemove(DRV_ADC_INPUTS_SCAN scanInput)
139:                 {
00000000  00000000   NOP
140:                     /* Remove Scan Input */
141:                     PLIB_ADC_InputScanMaskRemove(DRV_ADC_ID_1, scanInput);
00000014  00000000   NOP
142:                 }
00000024  00000000   NOP
143:                 
144:                 ADC_SAMPLE DRV_ADC_SamplesRead(uint8_t bufIndex)
145:                 {
00000000  00000000   NOP
146:                     /* Read Result */
147:                     return PLIB_ADC_ResultGetByIndex(DRV_ADC_ID_1, bufIndex);
00000018  00000000   NOP
148:                 }
0000002C  00000000   NOP
149:                 
150:                 bool DRV_ADC_SamplesAvailable(void)
151:                 {
00000000  00000000   NOP
152:                     /* Wait for DONE Flag */
153:                     while (!PLIB_ADC_ConversionHasCompleted(DRV_ADC_ID_1));
00000010  00000000   NOP
154:                 	
155:                     return true;
00000030  00000000   NOP
156:                 }
00000034  00000000   NOP
---  /home/david/microchip/harmony/projects/einkdisplay/firmware/src/main.c  ----------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Project Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for an MPLAB Harmony project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for an MPLAB Harmony project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state 
16:                      machines of all MPLAB Harmony modules in the system and it calls the 
17:                      "SYS_Tasks" function from within a system-wide "super" loop to maintain 
18:                      their correct operation. These two functions are implemented in 
19:                      configuration-specific files (usually "system_init.c" and "system_tasks.c")
20:                      in a configuration-specific folder under the "src/system_config" folder 
21:                      within this project's top-level folder.  An MPLAB Harmony project may have
22:                      more than one configuration, each contained within it's own folder under
23:                      the "system_config" folder.
24:                   *******************************************************************************/
25:                  
26:                  // DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  //Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                   *******************************************************************************/
49:                  // DOM-IGNORE-END
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Included Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include <stddef.h>                     // Defines NULL
59:                  #include <stdbool.h>                    // Defines true
60:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
61:                  #include "system/common/sys_module.h"   // SYS function prototypes
62:                  
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Main Entry Point
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  int main ( void )
71:                  {
9D002B4C  27BDFFE8   ADDIU SP, SP, -24
9D002B50  AFBF0014   SW RA, 20(SP)
9D002B54  AFBE0010   SW S8, 16(SP)
9D002B58  03A0F021   ADDU S8, SP, ZERO
72:                      /* Initialize all MPLAB Harmony modules, including application(s). */
73:                      SYS_Initialize ( NULL );
9D002B5C  00002021   ADDU A0, ZERO, ZERO
9D002B60  0F4005C7   JAL SYS_Initialize
9D002B64  00000000   NOP
74:                  
75:                  
76:                      while ( true )
77:                      {
78:                          /* Maintain state machines of all polled MPLAB Harmony modules. */
79:                          SYS_Tasks ( );
9D002B68  0F40097C   JAL SYS_Tasks
9D002B6C  00000000   NOP
80:                  
81:                      }
9D002B70  0B400ADA   J 0x9D002B68
9D002B74  00000000   NOP
82:                  
83:                      /* Execution should not come here during normal operation */
84:                  
85:                      return ( EXIT_FAILURE );
86:                  }
87:                  
88:                  
89:                  /*******************************************************************************
90:                   End of File
91:                  */
92:                  
---  /home/david/microchip/harmony/projects/einkdisplay/firmware/src/disp.c  ----------------------------
1:                   
2:                   #include "disp.h"
3:                   #include "system_definitions.h"
4:                   
5:                   inline void eink_delay( volatile uint16_t microseconds) {
9D00214C  27BDFFF8   ADDIU SP, SP, -8
9D002150  AFBE0004   SW S8, 4(SP)
9D002154  03A0F021   ADDU S8, SP, ZERO
9D002158  00801021   ADDU V0, A0, ZERO
9D00215C  A7C20008   SH V0, 8(S8)
6:                       while( microseconds > 0 ) {
9D002160  0B40085F   J 0x9D00217C
9D002164  00000000   NOP
9D00217C  97C20008   LHU V0, 8(S8)
9D002180  3042FFFF   ANDI V0, V0, -1
9D002184  1440FFF8   BNE V0, ZERO, 0x9D002168
9D002188  00000000   NOP
7:                           microseconds--;
9D002168  97C20008   LHU V0, 8(S8)
9D00216C  3042FFFF   ANDI V0, V0, -1
9D002170  2442FFFF   ADDIU V0, V0, -1
9D002174  3042FFFF   ANDI V0, V0, -1
9D002178  A7C20008   SH V0, 8(S8)
8:                       }
9:                   }
9D00218C  03C0E821   ADDU SP, S8, ZERO
9D002190  8FBE0004   LW S8, 4(SP)
9D002194  27BD0008   ADDIU SP, SP, 8
9D002198  03E00008   JR RA
9D00219C  00000000   NOP
10:                  
11:                  // display voltage supplies
12:                  // SMPS_CTRL RB3, active low
13:                  // VNEG_CTRL RF0, active high
14:                  // VPOS_CTRL RF1, active high
15:                  // eink_VDD - RD6, active high
16:                  
17:                  static inline void setpower_vdd ( volatile bool on ) {
9D0018F4  27BDFFE8   ADDIU SP, SP, -24
9D0018F8  AFBF0014   SW RA, 20(SP)
9D0018FC  AFBE0010   SW S8, 16(SP)
9D001900  03A0F021   ADDU S8, SP, ZERO
9D001904  00801021   ADDU V0, A0, ZERO
9D001908  A3C20018   SB V0, 24(S8)
18:                      // SMPS_CTRL - RB3 - active low
19:                      SYS_PORTS_PinClear(PORTS_ID_0, PORT_CHANNEL_B, 3);
9D00190C  00002021   ADDU A0, ZERO, ZERO
9D001910  24050001   ADDIU A1, ZERO, 1
9D001914  24060003   ADDIU A2, ZERO, 3
9D001918  0F400912   JAL SYS_PORTS_PinClear
9D00191C  00000000   NOP
20:                      SYS_PORTS_PinDirectionSelect(PORTS_ID_0, !on, PORT_CHANNEL_B, 3);
9D001920  93C20018   LBU V0, 24(S8)
9D001924  304200FF   ANDI V0, V0, 255
9D001928  38420001   XORI V0, V0, 1
9D00192C  304200FF   ANDI V0, V0, 255
9D001930  00002021   ADDU A0, ZERO, ZERO
9D001934  00402821   ADDU A1, V0, ZERO
9D001938  24060001   ADDIU A2, ZERO, 1
9D00193C  24070003   ADDIU A3, ZERO, 3
9D001940  0F4006E4   JAL SYS_PORTS_PinDirectionSelect
9D001944  00000000   NOP
21:                      // EINK_VDD - RD6 - active high
22:                      SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_D, 6, on);
9D001948  93C20018   LBU V0, 24(S8)
9D00194C  304200FF   ANDI V0, V0, 255
9D001950  00002021   ADDU A0, ZERO, ZERO
9D001954  24050003   ADDIU A1, ZERO, 3
9D001958  24060006   ADDIU A2, ZERO, 6
9D00195C  00403821   ADDU A3, V0, ZERO
9D001960  0F400828   JAL SYS_PORTS_PinWrite
9D001964  00000000   NOP
23:                  }
9D001968  03C0E821   ADDU SP, S8, ZERO
9D00196C  8FBF0014   LW RA, 20(SP)
9D001970  8FBE0010   LW S8, 16(SP)
9D001974  27BD0018   ADDIU SP, SP, 24
9D001978  03E00008   JR RA
9D00197C  00000000   NOP
24:                  
25:                  static inline void setpower_vneg ( volatile bool on ) {
9D0021F4  27BDFFE8   ADDIU SP, SP, -24
9D0021F8  AFBF0014   SW RA, 20(SP)
9D0021FC  AFBE0010   SW S8, 16(SP)
9D002200  03A0F021   ADDU S8, SP, ZERO
9D002204  00801021   ADDU V0, A0, ZERO
9D002208  A3C20018   SB V0, 24(S8)
26:                      //VNEG_CTRL - RF0 - active high
27:                      SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_F, 0, on);
9D00220C  93C20018   LBU V0, 24(S8)
9D002210  304200FF   ANDI V0, V0, 255
9D002214  00002021   ADDU A0, ZERO, ZERO
9D002218  24050005   ADDIU A1, ZERO, 5
9D00221C  00003021   ADDU A2, ZERO, ZERO
9D002220  00403821   ADDU A3, V0, ZERO
9D002224  0F400828   JAL SYS_PORTS_PinWrite
9D002228  00000000   NOP
28:                  }
9D00222C  03C0E821   ADDU SP, S8, ZERO
9D002230  8FBF0014   LW RA, 20(SP)
9D002234  8FBE0010   LW S8, 16(SP)
9D002238  27BD0018   ADDIU SP, SP, 24
9D00223C  03E00008   JR RA
9D002240  00000000   NOP
29:                  
30:                  static inline void setpower_vpos ( volatile bool on ) {
9D002244  27BDFFE8   ADDIU SP, SP, -24
9D002248  AFBF0014   SW RA, 20(SP)
9D00224C  AFBE0010   SW S8, 16(SP)
9D002250  03A0F021   ADDU S8, SP, ZERO
9D002254  00801021   ADDU V0, A0, ZERO
9D002258  A3C20018   SB V0, 24(S8)
31:                      //VPOS_CTRL - RF1 - active high
32:                      SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_F, 1, on);
9D00225C  93C20018   LBU V0, 24(S8)
9D002260  304200FF   ANDI V0, V0, 255
9D002264  00002021   ADDU A0, ZERO, ZERO
9D002268  24050005   ADDIU A1, ZERO, 5
9D00226C  24060001   ADDIU A2, ZERO, 1
9D002270  00403821   ADDU A3, V0, ZERO
9D002274  0F400828   JAL SYS_PORTS_PinWrite
9D002278  00000000   NOP
33:                  }
9D00227C  03C0E821   ADDU SP, S8, ZERO
9D002280  8FBF0014   LW RA, 20(SP)
9D002284  8FBE0010   LW S8, 16(SP)
9D002288  27BD0018   ADDIU SP, SP, 24
9D00228C  03E00008   JR RA
9D002290  00000000   NOP
34:                  
35:                  // display source driver
36:                  // CL - RD3
37:                  // OE - RD2
38:                  // LE - RD7
39:                  
40:                  static inline void setpin_le ( volatile bool on ) {
9D002630  27BDFFF8   ADDIU SP, SP, -8
9D002634  AFBE0004   SW S8, 4(SP)
9D002638  03A0F021   ADDU S8, SP, ZERO
9D00263C  00801021   ADDU V0, A0, ZERO
9D002640  A3C20008   SB V0, 8(S8)
41:                      // LE - RD7
42:                      LATDbits.LATD7 = on;
9D002644  93C20008   LBU V0, 8(S8)
9D002648  304400FF   ANDI A0, V0, 255
9D00264C  3C03BF88   LUI V1, -16504
9D002650  94626330   LHU V0, 25392(V1)
9D002654  7C8239C4   INS V0, A0, 7, 1
9D002658  A4626330   SH V0, 25392(V1)
43:                  }
9D00265C  03C0E821   ADDU SP, S8, ZERO
9D002660  8FBE0004   LW S8, 4(SP)
9D002664  27BD0008   ADDIU SP, SP, 8
9D002668  03E00008   JR RA
9D00266C  00000000   NOP
44:                  
45:                  static inline void setpin_oe ( volatile bool on ) {
9D002670  27BDFFF8   ADDIU SP, SP, -8
9D002674  AFBE0004   SW S8, 4(SP)
9D002678  03A0F021   ADDU S8, SP, ZERO
9D00267C  00801021   ADDU V0, A0, ZERO
9D002680  A3C20008   SB V0, 8(S8)
46:                      // RD2
47:                      LATDbits.LATD2 = on;
9D002684  93C20008   LBU V0, 8(S8)
9D002688  304400FF   ANDI A0, V0, 255
9D00268C  3C03BF88   LUI V1, -16504
9D002690  94626330   LHU V0, 25392(V1)
9D002694  7C821084   INS V0, A0, 2, 1
9D002698  A4626330   SH V0, 25392(V1)
48:                  }
9D00269C  03C0E821   ADDU SP, S8, ZERO
9D0026A0  8FBE0004   LW S8, 4(SP)
9D0026A4  27BD0008   ADDIU SP, SP, 8
9D0026A8  03E00008   JR RA
9D0026AC  00000000   NOP
49:                  
50:                  static inline void setpin_cl ( volatile bool on ) {
9D0026B0  27BDFFF8   ADDIU SP, SP, -8
9D0026B4  AFBE0004   SW S8, 4(SP)
9D0026B8  03A0F021   ADDU S8, SP, ZERO
9D0026BC  00801021   ADDU V0, A0, ZERO
9D0026C0  A3C20008   SB V0, 8(S8)
51:                      // RD3
52:                      LATDbits.LATD3 = on;
9D0026C4  93C20008   LBU V0, 8(S8)
9D0026C8  304400FF   ANDI A0, V0, 255
9D0026CC  3C03BF88   LUI V1, -16504
9D0026D0  94626330   LHU V0, 25392(V1)
9D0026D4  7C8218C4   INS V0, A0, 3, 1
9D0026D8  A4626330   SH V0, 25392(V1)
53:                  //    SYS_PORTS_PinWrite(PORTS_ID_0, PORT_CHANNEL_D, 3, on);
54:                  }
9D0026DC  03C0E821   ADDU SP, S8, ZERO
9D0026E0  8FBE0004   LW S8, 4(SP)
9D0026E4  27BD0008   ADDIU SP, SP, 8
9D0026E8  03E00008   JR RA
9D0026EC  00000000   NOP
55:                  
56:                  // display gate driver
57:                  // GMODE - RD1 - high at start of frame through row to end of frame
58:                  // SPH - RD8
59:                  // SPV - RC14 - rework
60:                  // CKV - RC13 - rework
61:                  
62:                  static inline void setpin_gmode ( volatile bool on ) {
9D0026F0  27BDFFF8   ADDIU SP, SP, -8
9D0026F4  AFBE0004   SW S8, 4(SP)
9D0026F8  03A0F021   ADDU S8, SP, ZERO
9D0026FC  00801021   ADDU V0, A0, ZERO
9D002700  A3C20008   SB V0, 8(S8)
63:                      // RD1
64:                      LATDbits.LATD1 = on;
9D002704  93C20008   LBU V0, 8(S8)
9D002708  304400FF   ANDI A0, V0, 255
9D00270C  3C03BF88   LUI V1, -16504
9D002710  94626330   LHU V0, 25392(V1)
9D002714  7C820844   INS V0, A0, 1, 1
9D002718  A4626330   SH V0, 25392(V1)
65:                  }
9D00271C  03C0E821   ADDU SP, S8, ZERO
9D002720  8FBE0004   LW S8, 4(SP)
9D002724  27BD0008   ADDIU SP, SP, 8
9D002728  03E00008   JR RA
9D00272C  00000000   NOP
66:                  
67:                  static inline void setpin_sph ( volatile bool on ) {
9D002730  27BDFFF8   ADDIU SP, SP, -8
9D002734  AFBE0004   SW S8, 4(SP)
9D002738  03A0F021   ADDU S8, SP, ZERO
9D00273C  00801021   ADDU V0, A0, ZERO
9D002740  A3C20008   SB V0, 8(S8)
68:                      // RD8
69:                      LATDbits.LATD8 = on;
9D002744  93C20008   LBU V0, 8(S8)
9D002748  304400FF   ANDI A0, V0, 255
9D00274C  3C03BF88   LUI V1, -16504
9D002750  94626330   LHU V0, 25392(V1)
9D002754  7C824204   INS V0, A0, 8, 1
9D002758  A4626330   SH V0, 25392(V1)
70:                  }
9D00275C  03C0E821   ADDU SP, S8, ZERO
9D002760  8FBE0004   LW S8, 4(SP)
9D002764  27BD0008   ADDIU SP, SP, 8
9D002768  03E00008   JR RA
9D00276C  00000000   NOP
71:                  
72:                  static inline void setpin_spv ( volatile bool on ) {
9D002770  27BDFFF8   ADDIU SP, SP, -8
9D002774  AFBE0004   SW S8, 4(SP)
9D002778  03A0F021   ADDU S8, SP, ZERO
9D00277C  00801021   ADDU V0, A0, ZERO
9D002780  A3C20008   SB V0, 8(S8)
73:                      // RC14
74:                      LATCbits.LATC14 = on;
9D002784  93C20008   LBU V0, 8(S8)
9D002788  304400FF   ANDI A0, V0, 255
9D00278C  3C03BF88   LUI V1, -16504
9D002790  94626230   LHU V0, 25136(V1)
9D002794  7C827384   INS V0, A0, 14, 1
9D002798  A4626230   SH V0, 25136(V1)
75:                  }
9D00279C  03C0E821   ADDU SP, S8, ZERO
9D0027A0  8FBE0004   LW S8, 4(SP)
9D0027A4  27BD0008   ADDIU SP, SP, 8
9D0027A8  03E00008   JR RA
9D0027AC  00000000   NOP
76:                  
77:                  static inline void setpin_ckv ( volatile bool on ) {
9D0027B0  27BDFFF8   ADDIU SP, SP, -8
9D0027B4  AFBE0004   SW S8, 4(SP)
9D0027B8  03A0F021   ADDU S8, SP, ZERO
9D0027BC  00801021   ADDU V0, A0, ZERO
9D0027C0  A3C20008   SB V0, 8(S8)
78:                      // RC13
79:                      LATCbits.LATC13 = on;
9D0027C4  93C20008   LBU V0, 8(S8)
9D0027C8  304400FF   ANDI A0, V0, 255
9D0027CC  3C03BF88   LUI V1, -16504
9D0027D0  94626230   LHU V0, 25136(V1)
9D0027D4  7C826B44   INS V0, A0, 13, 1
9D0027D8  A4626230   SH V0, 25136(V1)
80:                  }
9D0027DC  03C0E821   ADDU SP, S8, ZERO
9D0027E0  8FBE0004   LW S8, 4(SP)
9D0027E4  27BD0008   ADDIU SP, SP, 8
9D0027E8  03E00008   JR RA
9D0027EC  00000000   NOP
81:                  
82:                  // display data pins
83:                  // RE0-RE7
84:                  
85:                  static inline void setpins_data ( volatile uint8_t value ) {
9D002870  27BDFFF8   ADDIU SP, SP, -8
9D002874  AFBE0004   SW S8, 4(SP)
9D002878  03A0F021   ADDU S8, SP, ZERO
9D00287C  00801021   ADDU V0, A0, ZERO
9D002880  A3C20008   SB V0, 8(S8)
86:                      LATE = value;
9D002884  93C20008   LBU V0, 8(S8)
9D002888  304200FF   ANDI V0, V0, 255
9D00288C  00401821   ADDU V1, V0, ZERO
9D002890  3C02BF88   LUI V0, -16504
9D002894  AC436430   SW V1, 25648(V0)
87:                  }
9D002898  03C0E821   ADDU SP, S8, ZERO
9D00289C  8FBE0004   LW S8, 4(SP)
9D0028A0  27BD0008   ADDIU SP, SP, 8
9D0028A4  03E00008   JR RA
9D0028A8  00000000   NOP
88:                  
89:                  /* ====================================
90:                   *      Lower level driver functions
91:                   * ==================================== */
92:                  
93:                  /** Delay between signal changes, to give time for IO pins to change state. */
94:                  static inline void clockdelay()
95:                  {
9D002F3C  27BDFFF8   ADDIU SP, SP, -8
9D002F40  AFBE0004   SW S8, 4(SP)
9D002F44  03A0F021   ADDU S8, SP, ZERO
96:                  #if EINK_CLOCKDELAY & 1
97:                      asm("nop");
98:                  #endif
99:                  #if EINK_CLOCKDELAY & 2
100:                     asm("nop");
101:                     asm("nop");
102:                 #endif
103:                 #if EINK_CLOCKDELAY & 4
104:                     asm("nop");
105:                     asm("nop");
106:                     asm("nop");
107:                     asm("nop");
108:                 #endif
109:                 #if EINK_CLOCKDELAY & 8
110:                     asm("nop");
111:                     asm("nop");
112:                     asm("nop");
113:                     asm("nop");
114:                     asm("nop");
115:                     asm("nop");
116:                     asm("nop");
117:                     asm("nop");
118:                 #endif
119:                 }
9D002F48  03C0E821   ADDU SP, S8, ZERO
9D002F4C  8FBE0004   LW S8, 4(SP)
9D002F50  27BD0008   ADDIU SP, SP, 8
9D002F54  03E00008   JR RA
9D002F58  00000000   NOP
120:                 
121:                 /** Fast vertical clock pulse for gate driver, used during initializations */
122:                 static void vclock_quick()
123:                 {
9D0015AC  27BDFFF8   ADDIU SP, SP, -8
9D0015B0  AFBE0004   SW S8, 4(SP)
9D0015B4  03A0F021   ADDU S8, SP, ZERO
124:                     //setpin_ckv(TRUE;)
125:                     LATCbits.LATC13 = 1;
9D0015B8  3C03BF88   LUI V1, -16504
9D0015BC  94626230   LHU V0, 25136(V1)
9D0015C0  24040001   ADDIU A0, ZERO, 1
9D0015C4  7C826B44   INS V0, A0, 13, 1
9D0015C8  A4626230   SH V0, 25136(V1)
126:                     // delay ~10us (easiest with nop, although processor speed may change)
127:                     _nop();
9D0015CC  00000040   SSNOP
128:                     _nop();
9D0015D0  00000040   SSNOP
129:                     _nop();
9D0015D4  00000040   SSNOP
130:                     _nop();
9D0015D8  00000040   SSNOP
131:                     _nop();
9D0015DC  00000040   SSNOP
132:                     _nop();
9D0015E0  00000040   SSNOP
133:                     _nop();
9D0015E4  00000040   SSNOP
134:                     _nop();
9D0015E8  00000040   SSNOP
135:                     _nop();
9D0015EC  00000040   SSNOP
136:                     _nop();
9D0015F0  00000040   SSNOP
137:                     _nop();
9D0015F4  00000040   SSNOP
138:                     _nop();
9D0015F8  00000040   SSNOP
139:                     _nop();
9D0015FC  00000040   SSNOP
140:                     _nop();
9D001600  00000040   SSNOP
141:                     _nop();
9D001604  00000040   SSNOP
142:                     _nop();
9D001608  00000040   SSNOP
143:                     _nop();
9D00160C  00000040   SSNOP
144:                     _nop();
9D001610  00000040   SSNOP
145:                     _nop();
9D001614  00000040   SSNOP
146:                     _nop();
9D001618  00000040   SSNOP
147:                     //setpin_ckv(FALSE);
148:                     LATCbits.LATC13 = 0;
9D00161C  3C03BF88   LUI V1, -16504
9D001620  94626230   LHU V0, 25136(V1)
9D001624  7C026B44   INS V0, ZERO, 13, 1
9D001628  A4626230   SH V0, 25136(V1)
149:                     // delay ~5us?
150:                     _nop();
9D00162C  00000040   SSNOP
151:                     _nop();
9D001630  00000040   SSNOP
152:                     _nop();
9D001634  00000040   SSNOP
153:                     _nop();
9D001638  00000040   SSNOP
154:                     _nop();
9D00163C  00000040   SSNOP
155:                     _nop();
9D001640  00000040   SSNOP
156:                     _nop();
9D001644  00000040   SSNOP
157:                     _nop();
9D001648  00000040   SSNOP
158:                     _nop();
9D00164C  00000040   SSNOP
159:                     _nop();
9D001650  00000040   SSNOP
160:                 }
9D001654  03C0E821   ADDU SP, S8, ZERO
9D001658  8FBE0004   LW S8, 4(SP)
9D00165C  03E00008   JR RA
9D001660  27BD0008   ADDIU SP, SP, 8
161:                 
162:                 /** Horizontal clock pulse for clocking data into source driver */
163:                 static void hclock()
164:                 {
9D002328  27BDFFE8   ADDIU SP, SP, -24
9D00232C  AFBF0014   SW RA, 20(SP)
9D002330  AFBE0010   SW S8, 16(SP)
9D002334  03A0F021   ADDU S8, SP, ZERO
165:                     //clockdelay();
166:                     setpin_cl(TRUE);
9D002338  24040001   ADDIU A0, ZERO, 1
9D00233C  0F4009AC   JAL setpin_cl
9D002340  00000000   NOP
167:                     clockdelay();
9D002344  0F400BCF   JAL clockdelay
9D002348  00000000   NOP
168:                     setpin_cl(FALSE);
9D00234C  00002021   ADDU A0, ZERO, ZERO
9D002350  0F4009AC   JAL setpin_cl
9D002354  00000000   NOP
169:                 }
9D002358  03C0E821   ADDU SP, S8, ZERO
9D00235C  8FBF0014   LW RA, 20(SP)
9D002360  8FBE0010   LW S8, 16(SP)
9D002364  27BD0018   ADDIU SP, SP, 24
9D002368  03E00008   JR RA
9D00236C  00000000   NOP
170:                 
171:                 /** Start a new vertical gate driver scan from top.
172:                  * Note: Does not clear any previous bits in the shift register,
173:                  *       so you should always scan through the whole display before
174:                  *       starting a new scan.
175:                  */
176:                 static void vscan_start()
177:                 {
9D001C04  27BDFFE8   ADDIU SP, SP, -24
9D001C08  AFBF0014   SW RA, 20(SP)
9D001C0C  AFBE0010   SW S8, 16(SP)
9D001C10  03A0F021   ADDU S8, SP, ZERO
178:                     setpin_gmode(TRUE);
9D001C14  24040001   ADDIU A0, ZERO, 1
9D001C18  0F4009BC   JAL setpin_gmode
9D001C1C  00000000   NOP
179:                     vclock_quick();
9D001C20  0F40056B   JAL vclock_quick
9D001C24  00000000   NOP
180:                     setpin_spv(FALSE);
9D001C28  00002021   ADDU A0, ZERO, ZERO
9D001C2C  0F4009DC   JAL setpin_spv
9D001C30  00000000   NOP
181:                     vclock_quick();
9D001C34  0F40056B   JAL vclock_quick
9D001C38  00000000   NOP
182:                     setpin_spv(TRUE);
9D001C3C  24040001   ADDIU A0, ZERO, 1
9D001C40  0F4009DC   JAL setpin_spv
9D001C44  00000000   NOP
183:                     vclock_quick();
9D001C48  0F40056B   JAL vclock_quick
9D001C4C  00000000   NOP
184:                     setpin_oe(TRUE);
9D001C50  24040001   ADDIU A0, ZERO, 1
9D001C54  0F40099C   JAL setpin_oe
9D001C58  00000000   NOP
185:                 }
9D001C5C  03C0E821   ADDU SP, S8, ZERO
9D001C60  8FBF0014   LW RA, 20(SP)
9D001C64  8FBE0010   LW S8, 16(SP)
9D001C68  27BD0018   ADDIU SP, SP, 24
9D001C6C  03E00008   JR RA
9D001C70  00000000   NOP
186:                 
187:                 /** Waveform for strobing a row of data onto the display.
188:                  * Attempts to minimize the leaking of color to other rows by having
189:                  * a long idle period after a medium-length strobe period.
190:                  */
191:                 static void vscan_write()
192:                 {
9D002370  27BDFFE8   ADDIU SP, SP, -24
9D002374  AFBF0014   SW RA, 20(SP)
9D002378  AFBE0010   SW S8, 16(SP)
9D00237C  03A0F021   ADDU S8, SP, ZERO
193:                     // ckv on
194:                     setpin_ckv(TRUE);
9D002380  0F4009EC   JAL setpin_ckv
9D002384  24040001   ADDIU A0, ZERO, 1
195:                     // delay 5us -- don't need much, setpin call
196:                     _nop();
9D002388  00000040   SSNOP
197:                     _nop();
9D00238C  00000040   SSNOP
198:                     // ckv off
199:                     setpin_ckv(FALSE);
9D002390  00002021   ADDU A0, ZERO, ZERO
9D002394  0F4009EC   JAL setpin_ckv
9D002398  00000000   NOP
200:                     // delay 200us
201:                     eink_delay(70);
9D00239C  0F400853   JAL eink_delay
9D0023A0  24040046   ADDIU A0, ZERO, 70
202:                 }
9D0023A4  03C0E821   ADDU SP, S8, ZERO
9D0023A8  8FBF0014   LW RA, 20(SP)
9D0023AC  8FBE0010   LW S8, 16(SP)
9D0023B0  03E00008   JR RA
9D0023B4  27BD0018   ADDIU SP, SP, 24
203:                 
204:                 /** Waveform used when clearing the display. Strobes a row of data to the
205:                  * screen, but does not mind some of it leaking to other rows.
206:                  */
207:                 static void vscan_bulkwrite()
208:                 {
00000000  00000000   NOP
209:                     //setpin_oe(TRUE);
210:                     setpin_ckv(TRUE);
00000010  00000000   NOP
211:                     //eink_delay(20);
212:                     eink_delay(10);
0000001C  00000000   NOP
213:                     //setpin_oe(FALSE);
214:                     setpin_ckv(FALSE);
00000028  00000000   NOP
215:                     eink_delay(200);
00000034  00000000   NOP
216:                 }
00000040  00000000   NOP
217:                 
218:                 /** Waveform for skipping a vertical row without writing anything.
219:                  * Attempts to minimize the amount of change in any row.
220:                  */
221:                 static void vscan_skip()
222:                 {
00000000  00000000   NOP
223:                     //setpin_ckv(TRUE);
224:                     //eink_delay(1);
225:                     //setpin_ckv(FALSE);
226:                     LATCbits.LATC13 = 1;
00000010  00000000   NOP
227:                     _nop();
00000024  00000000   NOP
228:                     _nop();
00000028  00000000   NOP
229:                     LATCbits.LATC13 = 0;
0000002C  00000000   NOP
230:                     eink_delay(35);
0000003C  00000000   NOP
231:                 }
00000044  00000000   NOP
232:                 
233:                 /** Stop the vertical scan. The significance of this escapes me, but it seems
234:                  * necessary or the next vertical scan may be corrupted.
235:                  */
236:                 static void vscan_stop()
237:                 {
9D001EA4  27BDFFE8   ADDIU SP, SP, -24
9D001EA8  AFBF0014   SW RA, 20(SP)
9D001EAC  AFBE0010   SW S8, 16(SP)
9D001EB0  03A0F021   ADDU S8, SP, ZERO
238:                     setpin_gmode(FALSE);
9D001EB4  00002021   ADDU A0, ZERO, ZERO
9D001EB8  0F4009BC   JAL setpin_gmode
9D001EBC  00000000   NOP
239:                     setpin_oe(FALSE);
9D001EC0  00002021   ADDU A0, ZERO, ZERO
9D001EC4  0F40099C   JAL setpin_oe
9D001EC8  00000000   NOP
240:                     vclock_quick();
9D001ECC  0F40056B   JAL vclock_quick
9D001ED0  00000000   NOP
241:                     vclock_quick();
9D001ED4  0F40056B   JAL vclock_quick
9D001ED8  00000000   NOP
242:                     vclock_quick();
9D001EDC  0F40056B   JAL vclock_quick
9D001EE0  00000000   NOP
243:                     vclock_quick();
9D001EE4  0F40056B   JAL vclock_quick
9D001EE8  00000000   NOP
244:                     vclock_quick();
9D001EEC  0F40056B   JAL vclock_quick
9D001EF0  00000000   NOP
245:                 }
9D001EF4  03C0E821   ADDU SP, S8, ZERO
9D001EF8  8FBF0014   LW RA, 20(SP)
9D001EFC  8FBE0010   LW S8, 16(SP)
9D001F00  27BD0018   ADDIU SP, SP, 24
9D001F04  03E00008   JR RA
9D001F08  00000000   NOP
246:                 
247:                 /** Start updating the source driver data (from left to right). */
248:                 static void hscan_start()
249:                 {
9D0027F0  27BDFFE8   ADDIU SP, SP, -24
9D0027F4  AFBF0014   SW RA, 20(SP)
9D0027F8  AFBE0010   SW S8, 16(SP)
9D0027FC  03A0F021   ADDU S8, SP, ZERO
250:                     /* Disable latching and output enable while we are modifying the row. */
251:                     setpin_le(FALSE);
9D002800  00002021   ADDU A0, ZERO, ZERO
9D002804  0F40098C   JAL setpin_le
9D002808  00000000   NOP
252:                     //setpin_oe(FALSE);
253:                     
254:                     /* The start pulse should remain low for the duration of the row. */
255:                     setpin_sph(FALSE);
9D00280C  00002021   ADDU A0, ZERO, ZERO
9D002810  0F4009CC   JAL setpin_sph
9D002814  00000000   NOP
256:                 }
9D002818  03C0E821   ADDU SP, S8, ZERO
9D00281C  8FBF0014   LW RA, 20(SP)
9D002820  8FBE0010   LW S8, 16(SP)
9D002824  27BD0018   ADDIU SP, SP, 24
9D002828  03E00008   JR RA
9D00282C  00000000   NOP
257:                 
258:                 /** Write data to the horizontal row. */
259:                 static void hscan_write(const uint8_t *data, int count)
260:                 {
00000000  00000000   NOP
261:                     while (count--)
00000018  00000000   NOP
00000044  00000000   NOP
262:                     {
263:                         /* Set the next byte on the data pins */
264:                         setpins_data(*data++);
00000020  00000000   NOP
265:                         
266:                         /* Give a clock pulse to the shift register */
267:                         hclock();
0000003C  00000000   NOP
268:                     }
269:                 }
00000058  00000000   NOP
270:                 
271:                 /** Finish and transfer the row to the source drivers.
272:                  * Does not set the output enable, so the drivers are not yet active. */
273:                 static void hscan_stop()
274:                 {
9D002044  27BDFFE8   ADDIU SP, SP, -24
9D002048  AFBF0014   SW RA, 20(SP)
9D00204C  AFBE0010   SW S8, 16(SP)
9D002050  03A0F021   ADDU S8, SP, ZERO
275:                     /* End the scan */
276:                     setpin_sph(TRUE);
9D002054  24040001   ADDIU A0, ZERO, 1
9D002058  0F4009CC   JAL setpin_sph
9D00205C  00000000   NOP
277:                     hclock();
9D002060  0F4008CA   JAL hclock
9D002064  00000000   NOP
278:                     
279:                     /* Latch the new data */
280:                     setpin_le(TRUE);
9D002068  24040001   ADDIU A0, ZERO, 1
9D00206C  0F40098C   JAL setpin_le
9D002070  00000000   NOP
281:                     clockdelay();
9D002074  0F400BCF   JAL clockdelay
9D002078  00000000   NOP
282:                     setpin_le(FALSE);
9D00207C  00002021   ADDU A0, ZERO, ZERO
9D002080  0F40098C   JAL setpin_le
9D002084  00000000   NOP
283:                 }
9D002088  03C0E821   ADDU SP, S8, ZERO
9D00208C  8FBF0014   LW RA, 20(SP)
9D002090  8FBE0010   LW S8, 16(SP)
9D002094  27BD0018   ADDIU SP, SP, 24
9D002098  03E00008   JR RA
9D00209C  00000000   NOP
284:                 
285:                 /** Turn on the power to the E-Ink panel, observing proper power sequencing. */
286:                 static void power_on()
287:                 {
9D000C80  27BDFFE0   ADDIU SP, SP, -32
9D000C84  AFBF001C   SW RA, 28(SP)
9D000C88  AFBE0018   SW S8, 24(SP)
9D000C8C  03A0F021   ADDU S8, SP, ZERO
288:                     volatile unsigned i;
289:                     
290:                     /* First the digital power supply and signal levels. */
291:                     setpower_vdd(TRUE);
9D000C90  24040001   ADDIU A0, ZERO, 1
9D000C94  0F40063D   JAL setpower_vdd
9D000C98  00000000   NOP
292:                     setpin_le(FALSE);
9D000C9C  00002021   ADDU A0, ZERO, ZERO
9D000CA0  0F40098C   JAL setpin_le
9D000CA4  00000000   NOP
293:                     setpin_oe(FALSE);
9D000CA8  00002021   ADDU A0, ZERO, ZERO
9D000CAC  0F40099C   JAL setpin_oe
9D000CB0  00000000   NOP
294:                     setpin_cl(FALSE);
9D000CB4  00002021   ADDU A0, ZERO, ZERO
9D000CB8  0F4009AC   JAL setpin_cl
9D000CBC  00000000   NOP
295:                     setpin_sph(TRUE);
9D000CC0  24040001   ADDIU A0, ZERO, 1
9D000CC4  0F4009CC   JAL setpin_sph
9D000CC8  00000000   NOP
296:                     setpins_data(0);
9D000CCC  00002021   ADDU A0, ZERO, ZERO
9D000CD0  0F400A1C   JAL setpins_data
9D000CD4  00000000   NOP
297:                     setpin_ckv(FALSE);
9D000CD8  00002021   ADDU A0, ZERO, ZERO
9D000CDC  0F4009EC   JAL setpin_ckv
9D000CE0  00000000   NOP
298:                     setpin_gmode(FALSE);
9D000CE4  00002021   ADDU A0, ZERO, ZERO
9D000CE8  0F4009BC   JAL setpin_gmode
9D000CEC  00000000   NOP
299:                     setpin_spv(TRUE);
9D000CF0  24040001   ADDIU A0, ZERO, 1
9D000CF4  0F4009DC   JAL setpin_spv
9D000CF8  00000000   NOP
300:                     
301:                     /* Min. 100 microsecond delay after digital supply */
302:                     eink_delay(1000);
9D000CFC  240403E8   ADDIU A0, ZERO, 1000
9D000D00  0F400853   JAL eink_delay
9D000D04  00000000   NOP
303:                     
304:                     /* Then negative voltages and min. 1000 microsecond delay. */
305:                     setpower_vneg(TRUE);
9D000D08  24040001   ADDIU A0, ZERO, 1
9D000D0C  0F40087D   JAL setpower_vneg
9D000D10  00000000   NOP
306:                     eink_delay(3000);
9D000D14  24040BB8   ADDIU A0, ZERO, 3000
9D000D18  0F400853   JAL eink_delay
9D000D1C  00000000   NOP
307:                     
308:                     /* Finally the positive voltages. */
309:                     setpower_vpos(TRUE);
9D000D20  24040001   ADDIU A0, ZERO, 1
9D000D24  0F400891   JAL setpower_vpos
9D000D28  00000000   NOP
310:                     eink_delay(3000);
9D000D2C  24040BB8   ADDIU A0, ZERO, 3000
9D000D30  0F400853   JAL eink_delay
9D000D34  00000000   NOP
311:                     
312:                     /* Clear the vscan shift register */
313:                     vscan_start();
9D000D38  0F400701   JAL vscan_start
9D000D3C  00000000   NOP
314:                     for (i = 0; i < DISP_HEIGHT; i++)
9D000D40  AFC00010   SW ZERO, 16(S8)
9D000D44  0B400358   J 0x9D000D60
9D000D48  00000000   NOP
9D000D54  8FC20010   LW V0, 16(S8)
9D000D58  24420001   ADDIU V0, V0, 1
9D000D5C  AFC20010   SW V0, 16(S8)
9D000D60  8FC20010   LW V0, 16(S8)
9D000D64  2C420258   SLTIU V0, V0, 600
9D000D68  1440FFF8   BNE V0, ZERO, 0x9D000D4C
9D000D6C  00000000   NOP
315:                         vclock_quick();
9D000D4C  0F40056B   JAL vclock_quick
9D000D50  00000000   NOP
316:                     vscan_stop();
9D000D70  0F4007A9   JAL vscan_stop
9D000D74  00000000   NOP
317:                 }
9D000D78  03C0E821   ADDU SP, S8, ZERO
9D000D7C  8FBF001C   LW RA, 28(SP)
9D000D80  8FBE0018   LW S8, 24(SP)
9D000D84  27BD0020   ADDIU SP, SP, 32
9D000D88  03E00008   JR RA
9D000D8C  00000000   NOP
318:                 
319:                 /** Turn off the power, observing proper power sequencing. */
320:                 static void power_off()
321:                 {
9D001664  27BDFFE8   ADDIU SP, SP, -24
9D001668  AFBF0014   SW RA, 20(SP)
9D00166C  AFBE0010   SW S8, 16(SP)
9D001670  03A0F021   ADDU S8, SP, ZERO
322:                     /* First the high voltages */
323:                     setpower_vpos(FALSE);
9D001674  00002021   ADDU A0, ZERO, ZERO
9D001678  0F400891   JAL setpower_vpos
9D00167C  00000000   NOP
324:                     setpower_vneg(FALSE);
9D001680  00002021   ADDU A0, ZERO, ZERO
9D001684  0F40087D   JAL setpower_vneg
9D001688  00000000   NOP
325:                     
326:                     /* Wait for any capacitors to drain */
327:                     eink_delay(5000);
9D00168C  24041388   ADDIU A0, ZERO, 5000
9D001690  0F400853   JAL eink_delay
9D001694  00000000   NOP
328:                     
329:                     /* Then put all signals and digital supply to ground. */
330:                     setpin_le(FALSE);
9D001698  00002021   ADDU A0, ZERO, ZERO
9D00169C  0F40098C   JAL setpin_le
9D0016A0  00000000   NOP
331:                     setpin_oe(FALSE);
9D0016A4  00002021   ADDU A0, ZERO, ZERO
9D0016A8  0F40099C   JAL setpin_oe
9D0016AC  00000000   NOP
332:                     setpin_cl(FALSE);
9D0016B0  00002021   ADDU A0, ZERO, ZERO
9D0016B4  0F4009AC   JAL setpin_cl
9D0016B8  00000000   NOP
333:                     setpin_sph(FALSE);
9D0016BC  00002021   ADDU A0, ZERO, ZERO
9D0016C0  0F4009CC   JAL setpin_sph
9D0016C4  00000000   NOP
334:                     setpins_data(0);
9D0016C8  00002021   ADDU A0, ZERO, ZERO
9D0016CC  0F400A1C   JAL setpins_data
9D0016D0  00000000   NOP
335:                     setpin_ckv(FALSE);
9D0016D4  00002021   ADDU A0, ZERO, ZERO
9D0016D8  0F4009EC   JAL setpin_ckv
9D0016DC  00000000   NOP
336:                     setpin_gmode(FALSE);
9D0016E0  00002021   ADDU A0, ZERO, ZERO
9D0016E4  0F4009BC   JAL setpin_gmode
9D0016E8  00000000   NOP
337:                     setpin_spv(FALSE);
9D0016EC  00002021   ADDU A0, ZERO, ZERO
9D0016F0  0F4009DC   JAL setpin_spv
9D0016F4  00000000   NOP
338:                     setpower_vdd(FALSE);
9D0016F8  00002021   ADDU A0, ZERO, ZERO
9D0016FC  0F40063D   JAL setpower_vdd
9D001700  00000000   NOP
339:                 }
9D001704  03C0E821   ADDU SP, S8, ZERO
9D001708  8FBF0014   LW RA, 20(SP)
9D00170C  8FBE0010   LW S8, 16(SP)
9D001710  27BD0018   ADDIU SP, SP, 24
9D001714  03E00008   JR RA
9D001718  00000000   NOP
340:                 
341:                 /* ===============================
342:                  *         Public functions
343:                  *  static keyword prevents external access
344:                  * =============================== */
345:                 
346:                 void eink_startup (void) {
9D002A30  27BDFFE8   ADDIU SP, SP, -24
9D002A34  AFBF0014   SW RA, 20(SP)
9D002A38  AFBE0010   SW S8, 16(SP)
9D002A3C  03A0F021   ADDU S8, SP, ZERO
347:                     power_on();
9D002A40  0F400320   JAL power_on
9D002A44  00000000   NOP
348:                 }
9D002A48  03C0E821   ADDU SP, S8, ZERO
9D002A4C  8FBF0014   LW RA, 20(SP)
9D002A50  8FBE0010   LW S8, 16(SP)
9D002A54  27BD0018   ADDIU SP, SP, 24
9D002A58  03E00008   JR RA
9D002A5C  00000000   NOP
349:                 
350:                 void eink_shutdown (void) {
9D002A60  27BDFFE8   ADDIU SP, SP, -24
9D002A64  AFBF0014   SW RA, 20(SP)
9D002A68  AFBE0010   SW S8, 16(SP)
9D002A6C  03A0F021   ADDU S8, SP, ZERO
351:                     power_off();
9D002A70  0F400599   JAL power_off
9D002A74  00000000   NOP
352:                 }
9D002A78  03C0E821   ADDU SP, S8, ZERO
9D002A7C  8FBF0014   LW RA, 20(SP)
9D002A80  8FBE0010   LW S8, 16(SP)
9D002A84  27BD0018   ADDIU SP, SP, 24
9D002A88  03E00008   JR RA
9D002A8C  00000000   NOP
353:                 
354:                 void eink_test_fill (volatile uint8_t fill_color) {
9D000F54  27BDFFE0   ADDIU SP, SP, -32
9D000F58  AFBF001C   SW RA, 28(SP)
9D000F5C  AFBE0018   SW S8, 24(SP)
9D000F60  03A0F021   ADDU S8, SP, ZERO
9D000F64  00801021   ADDU V0, A0, ZERO
9D000F68  A3C20020   SB V0, 32(S8)
355:                     volatile uint16_t xCounter, yCounter;
356:                 
357:                     vscan_start();
9D000F6C  0F400701   JAL vscan_start
9D000F70  00000000   NOP
358:                 
359:                     for ( yCounter = 0; yCounter < 600; yCounter++ ) {
9D000F74  A7C00012   SH ZERO, 18(S8)
9D000F78  0B4003FF   J 0x9D000FFC
9D000F7C  00000000   NOP
9D000FE8  97C20012   LHU V0, 18(S8)
9D000FEC  3042FFFF   ANDI V0, V0, -1
9D000FF0  24420001   ADDIU V0, V0, 1
9D000FF4  3042FFFF   ANDI V0, V0, -1
9D000FF8  A7C20012   SH V0, 18(S8)
9D000FFC  97C20012   LHU V0, 18(S8)
9D001000  3042FFFF   ANDI V0, V0, -1
9D001004  2C420258   SLTIU V0, V0, 600
9D001008  1440FFDD   BNE V0, ZERO, 0x9D000F80
9D00100C  00000000   NOP
360:                         hscan_start();
9D000F80  0F4009FC   JAL hscan_start
9D000F84  00000000   NOP
361:                         for ( xCounter = 0; xCounter < 200; xCounter++ ) {
9D000F88  A7C00010   SH ZERO, 16(S8)
9D000F8C  0B4003F1   J 0x9D000FC4
9D000F90  00000000   NOP
9D000FB0  97C20010   LHU V0, 16(S8)
9D000FB4  3042FFFF   ANDI V0, V0, -1
9D000FB8  24420001   ADDIU V0, V0, 1
9D000FBC  3042FFFF   ANDI V0, V0, -1
9D000FC0  A7C20010   SH V0, 16(S8)
9D000FC4  97C20010   LHU V0, 16(S8)
9D000FC8  3042FFFF   ANDI V0, V0, -1
9D000FCC  2C4200C8   SLTIU V0, V0, 200
9D000FD0  1440FFF0   BNE V0, ZERO, 0x9D000F94
9D000FD4  00000000   NOP
362:                             setpins_data(fill_color);
9D000F94  93C20020   LBU V0, 32(S8)
9D000F98  304200FF   ANDI V0, V0, 255
9D000F9C  00402021   ADDU A0, V0, ZERO
9D000FA0  0F400A1C   JAL setpins_data
9D000FA4  00000000   NOP
363:                             hclock();
9D000FA8  0F4008CA   JAL hclock
9D000FAC  00000000   NOP
364:                         }
365:                         hscan_stop();
9D000FD8  0F400811   JAL hscan_stop
9D000FDC  00000000   NOP
366:                         vscan_write();
9D000FE0  0F4008DC   JAL vscan_write
9D000FE4  00000000   NOP
367:                     }
368:                     vscan_stop();
9D001010  0F4007A9   JAL vscan_stop
9D001014  00000000   NOP
369:                 }
9D001018  03C0E821   ADDU SP, S8, ZERO
9D00101C  8FBF001C   LW RA, 28(SP)
9D001020  8FBE0018   LW S8, 24(SP)
9D001024  27BD0020   ADDIU SP, SP, 32
9D001028  03E00008   JR RA
9D00102C  00000000   NOP
370:                 
371:                 void eink_test_plaid(bool white_background) {
00000000  00000000   NOP
372:                     
373:                 }
00000014  00000000   NOP
374:                 
375:                 void buffer_set_pixel(uint16_t xpos, uint16_t ypos, uint8_t color) {
00000000  00000000   NOP
376:                     
377:                 }
00000020  00000000   NOP
378:                 
379:                 void buffer_draw_line(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint8_t color) {
00000000  00000000   NOP
380:                     
381:                 }
00000030  00000000   NOP
382:                 
383:                 void eink_write_buffer(uint8_t *buffer) {
00000000  00000000   NOP
384:                     
385:                 }
00000010  00000000   NOP
---  /home/david/microchip/harmony/projects/einkdisplay/firmware/src/app.c  -----------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app.h"
57:                  #include "disp.h"
58:                  #include "system_definitions.h"
59:                  
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  // Section: Global Data Definitions
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  
66:                  // *****************************************************************************
67:                  /* Application Data
68:                  
69:                    Summary:
70:                      Holds application data
71:                  
72:                    Description:
73:                      This structure holds the application's data.
74:                  
75:                    Remarks:
76:                      This structure should be initialized by the APP_Initialize function.
77:                      
78:                      Application strings and buffers are be defined outside this structure.
79:                  */
80:                  
81:                  APP_DATA appData;
82:                  
83:                  // *****************************************************************************
84:                  // *****************************************************************************
85:                  // Section: Application Callback Functions
86:                  // *****************************************************************************
87:                  // *****************************************************************************
88:                  
89:                  /* TODO:  Add any necessary callback funtions.
90:                  */
91:                  
92:                  // *****************************************************************************
93:                  // *****************************************************************************
94:                  // Section: Application Local Functions
95:                  // *****************************************************************************
96:                  // *****************************************************************************
97:                  
98:                  /* TODO:  Add any necessary local functions.
99:                  */
100:                 
101:                 
102:                 // *****************************************************************************
103:                 // *****************************************************************************
104:                 // Section: Application Initialization and State Machine Functions
105:                 // *****************************************************************************
106:                 // *****************************************************************************
107:                 
108:                 /*******************************************************************************
109:                   Function:
110:                     void APP_Initialize ( void )
111:                 
112:                   Remarks:
113:                     See prototype in app.h.
114:                  */
115:                 
116:                 void APP_Initialize ( void )
117:                 {
9D0022E0  27BDFFE8   ADDIU SP, SP, -24
9D0022E4  AFBF0014   SW RA, 20(SP)
9D0022E8  AFBE0010   SW S8, 16(SP)
9D0022EC  03A0F021   ADDU S8, SP, ZERO
118:                     /* Place the App state machine in its initial state. */
119:                     appData.state = APP_STATE_SLEEP;
9D0022F0  AF808024   SW ZERO, -32732(GP)
120:                     SYS_PORTS_PinSet(PORTS_ID_0, PORT_CHANNEL_D, 0); // green LED off
9D0022F4  00002021   ADDU A0, ZERO, ZERO
9D0022F8  24050003   ADDIU A1, ZERO, 3
9D0022FC  00003021   ADDU A2, ZERO, ZERO
9D002300  0F400900   JAL SYS_PORTS_PinSet
9D002304  00000000   NOP
121:                     
122:                     DRV_TMR0_Start();
9D002308  0F400A65   JAL DRV_TMR0_Start
9D00230C  00000000   NOP
123:                 }
9D002310  03C0E821   ADDU SP, S8, ZERO
9D002314  8FBF0014   LW RA, 20(SP)
9D002318  8FBE0010   LW S8, 16(SP)
9D00231C  27BD0018   ADDIU SP, SP, 24
9D002320  03E00008   JR RA
9D002324  00000000   NOP
124:                 
125:                 
126:                 /******************************************************************************
127:                   Function:
128:                     void APP_Tasks ( void )
129:                 
130:                   Remarks:
131:                     See prototype in app.h.
132:                  */
133:                 
134:                     // TODO: turn on switching regulators
135:                     // turn on (low) power supply mosfet from RB3 -- P-MOSFET inversion!
136:                     // turn on (high) switching pos and neg via RF0 and RF1
137:                 
138:                     // NOTE:
139:                     // RD0 -- outside, blue on board, active low
140:                     // RD9 -- inside, green on board, active high
141:                     // pin 21 - SW2 - RB8
142:                     // pin 40 - SW1 - RC15
143:                 
144:                     // also NOTE:  This code has issues when optimization is set (greater than 0)
145:                     // optimizations are re-set to 1 every time harmony is updated?
146:                     
147:                 
148:                 #define SW1INPUT            SYS_PORTS_PinRead(PORTS_ID_0, PORT_CHANNEL_C, 15)
149:                 #define SW2INPUT            SYS_PORTS_PinRead(PORTS_ID_0, PORT_CHANNEL_B, 8)
150:                 #define SWDOWNCOUNT         100
151:                 
152:                 #define GREENLEDON()        SYS_PORTS_PinClear(PORTS_ID_0, PORT_CHANNEL_D, 0)
153:                 #define GREENLEDOFF()       SYS_PORTS_PinSet(PORTS_ID_0, PORT_CHANNEL_D, 0)
154:                 #define GREENLEDTOGGLE()    SYS_PORTS_PinToggle(PORTS_ID_0, PORT_CHANNEL_D, 0)
155:                 #define BLUELEDON()         SYS_PORTS_PinSet(PORTS_ID_0, PORT_CHANNEL_D, 9)
156:                 #define BLUELEDOFF()        SYS_PORTS_PinClear(PORTS_ID_0, PORT_CHANNEL_D, 9)
157:                 #define BLUELEDTOGGLE()     SYS_PORTS_PinToggle(PORTS_ID_0, PORT_CHANNEL_D, 9)
158:                 
159:                 void APP_Tasks ( void )
160:                 {
9D000370  27BDFFE0   ADDIU SP, SP, -32
9D000374  AFBF001C   SW RA, 28(SP)
9D000378  AFBE0018   SW S8, 24(SP)
9D00037C  03A0F021   ADDU S8, SP, ZERO
161:                     volatile uint8_t switch1Counter, switch2Counter;
162:                     volatile uint16_t counter;
163:                     
164:                     /* Check the application's current state. */
165:                     switch ( appData.state )
9D000380  8F828024   LW V0, -32732(GP)
9D000384  24030001   ADDIU V1, ZERO, 1
9D000388  10430070   BEQ V0, V1, 0x9D00054C
9D00038C  00000000   NOP
9D000390  2C430001   SLTIU V1, V0, 1
9D000394  14600006   BNE V1, ZERO, 0x9D0003B0
9D000398  00000000   NOP
9D00039C  24030002   ADDIU V1, ZERO, 2
9D0003A0  1043007C   BEQ V0, V1, 0x9D000594
9D0003A4  00000000   NOP
166:                     {
167:                         /* Application's initial state. */
168:                         case APP_STATE_SLEEP:
169:                         {
170:                             if ( 1 == IFS0bits.T1IF ) {
9D0003B0  3C02BF88   LUI V0, -16504
9D0003B4  8C421030   LW V0, 4144(V0)
9D0003B8  30420010   ANDI V0, V0, 16
9D0003BC  10400061   BEQ V0, ZERO, 0x9D000544
9D0003C0  00000000   NOP
171:                                 IFS0bits.T1IF = 0;
9D0003C4  3C03BF88   LUI V1, -16504
9D0003C8  8C621030   LW V0, 4144(V1)
9D0003CC  7C022104   INS V0, ZERO, 4, 1
9D0003D0  AC621030   SW V0, 4144(V1)
172:                             
173:                                 // check button inputs
174:                                 if ( 0 == SW2INPUT ) {
9D0003D4  00002021   ADDU A0, ZERO, ZERO
9D0003D8  24050001   ADDIU A1, ZERO, 1
9D0003DC  24060008   ADDIU A2, ZERO, 8
9D0003E0  0F4008EE   JAL SYS_PORTS_PinRead
9D0003E4  00000000   NOP
9D0003E8  38420001   XORI V0, V0, 1
9D0003EC  304200FF   ANDI V0, V0, 255
9D0003F0  1040001F   BEQ V0, ZERO, 0x9D000470
9D0003F4  00000000   NOP
175:                                     switch2Counter++;
9D0003F8  93C20011   LBU V0, 17(S8)
9D0003FC  304200FF   ANDI V0, V0, 255
9D000400  24420001   ADDIU V0, V0, 1
9D000404  304200FF   ANDI V0, V0, 255
9D000408  A3C20011   SB V0, 17(S8)
176:                                     
177:                                     if ( switch2Counter > SWDOWNCOUNT ) {
9D00040C  93C20011   LBU V0, 17(S8)
9D000410  304200FF   ANDI V0, V0, 255
9D000414  2C420065   SLTIU V0, V0, 101
9D000418  1440001B   BNE V0, ZERO, 0x9D000488
9D00041C  00000000   NOP
178:                                         GREENLEDON();
9D000420  00002021   ADDU A0, ZERO, ZERO
9D000424  24050003   ADDIU A1, ZERO, 3
9D000428  00003021   ADDU A2, ZERO, ZERO
9D00042C  0F400912   JAL SYS_PORTS_PinClear
9D000430  00000000   NOP
179:                                         while( 0 == SW2INPUT );
9D000434  00000000   NOP
9D000438  00002021   ADDU A0, ZERO, ZERO
9D00043C  24050001   ADDIU A1, ZERO, 1
9D000440  24060008   ADDIU A2, ZERO, 8
9D000444  0F4008EE   JAL SYS_PORTS_PinRead
9D000448  00000000   NOP
9D00044C  38420001   XORI V0, V0, 1
9D000450  304200FF   ANDI V0, V0, 255
9D000454  1440FFF8   BNE V0, ZERO, 0x9D000438
9D000458  00000000   NOP
180:                                         switch2Counter = 0;
9D00045C  A3C00011   SB ZERO, 17(S8)
181:                                         appData.state = APP_STATE_DRAW;
9D000460  24020001   ADDIU V0, ZERO, 1
9D000464  AF828024   SW V0, -32732(GP)
182:                                         break;
9D000468  0B400176   J 0x9D0005D8
9D00046C  00000000   NOP
183:                                     }
184:                                     
185:                                 } else {
186:                                     switch2Counter = 0;
9D000470  A3C00011   SB ZERO, 17(S8)
187:                                     GREENLEDOFF();
9D000474  00002021   ADDU A0, ZERO, ZERO
9D000478  24050003   ADDIU A1, ZERO, 3
9D00047C  00003021   ADDU A2, ZERO, ZERO
9D000480  0F400900   JAL SYS_PORTS_PinSet
9D000484  00000000   NOP
188:                                 }
189:                                 if ( 0 == SW1INPUT ) {
9D000488  00002021   ADDU A0, ZERO, ZERO
9D00048C  24050002   ADDIU A1, ZERO, 2
9D000490  2406000F   ADDIU A2, ZERO, 15
9D000494  0F4008EE   JAL SYS_PORTS_PinRead
9D000498  00000000   NOP
9D00049C  38420001   XORI V0, V0, 1
9D0004A0  304200FF   ANDI V0, V0, 255
9D0004A4  1040001F   BEQ V0, ZERO, 0x9D000524
9D0004A8  00000000   NOP
190:                                     switch1Counter++;
9D0004AC  93C20010   LBU V0, 16(S8)
9D0004B0  304200FF   ANDI V0, V0, 255
9D0004B4  24420001   ADDIU V0, V0, 1
9D0004B8  304200FF   ANDI V0, V0, 255
9D0004BC  A3C20010   SB V0, 16(S8)
191:                                     
192:                                     if ( switch1Counter > SWDOWNCOUNT ) {
9D0004C0  93C20010   LBU V0, 16(S8)
9D0004C4  304200FF   ANDI V0, V0, 255
9D0004C8  2C420065   SLTIU V0, V0, 101
9D0004CC  1440001D   BNE V0, ZERO, 0x9D000544
9D0004D0  00000000   NOP
193:                                         BLUELEDON();
9D0004D4  00002021   ADDU A0, ZERO, ZERO
9D0004D8  24050003   ADDIU A1, ZERO, 3
9D0004DC  24060009   ADDIU A2, ZERO, 9
9D0004E0  0F400900   JAL SYS_PORTS_PinSet
9D0004E4  00000000   NOP
194:                                         while( 0 == SW1INPUT );
9D0004E8  00000000   NOP
9D0004EC  00002021   ADDU A0, ZERO, ZERO
9D0004F0  24050002   ADDIU A1, ZERO, 2
9D0004F4  2406000F   ADDIU A2, ZERO, 15
9D0004F8  0F4008EE   JAL SYS_PORTS_PinRead
9D0004FC  00000000   NOP
9D000500  38420001   XORI V0, V0, 1
9D000504  304200FF   ANDI V0, V0, 255
9D000508  1440FFF8   BNE V0, ZERO, 0x9D0004EC
9D00050C  00000000   NOP
195:                                         switch1Counter = 0;
9D000510  A3C00010   SB ZERO, 16(S8)
196:                                         appData.state = APP_STATE_CLEAR;
9D000514  24020002   ADDIU V0, ZERO, 2
9D000518  AF828024   SW V0, -32732(GP)
197:                                         break;
9D00051C  0B400176   J 0x9D0005D8
9D000520  00000000   NOP
198:                                     }
199:                                     
200:                                 } else {
201:                                     switch1Counter = 0;
9D000524  A3C00010   SB ZERO, 16(S8)
202:                                     BLUELEDOFF();
9D000528  00002021   ADDU A0, ZERO, ZERO
9D00052C  24050003   ADDIU A1, ZERO, 3
9D000530  24060009   ADDIU A2, ZERO, 9
9D000534  0F400912   JAL SYS_PORTS_PinClear
9D000538  00000000   NOP
203:                                 }
204:                             }
205:                             
206:                             break;
9D00053C  0B400176   J 0x9D0005D8
9D000540  00000000   NOP
9D000544  0B400176   J 0x9D0005D8
9D000548  00000000   NOP
207:                         }
208:                         case APP_STATE_DRAW:
209:                         {
210:                             
211:                 //            if ( 1 == IFS0bits.T1IF ) {
212:                 //                IFS0bits.T1IF = 0;
213:                 //                
214:                 //                if ( 0 == SW1INPUT ) {
215:                 //                    switch1Counter++;
216:                 //                    
217:                 //                    if ( switch1Counter > SWDOWNCOUNT ) {
218:                 //                        BLUELEDTOGGLE();
219:                 //                        while( 0 == SW1INPUT );
220:                 //                        switch1Counter = 0;
221:                 //                    }
222:                 //                } else {
223:                 //                    switch1Counter = 0;
224:                 //                }
225:                 //            
226:                 //                // check button input
227:                 //                if ( 0 == SW2INPUT ) {
228:                 //                    switch2Counter++;
229:                 //                    
230:                 //                    if ( switch2Counter > SWDOWNCOUNT ) {
231:                 //                        GREENLEDOFF();
232:                 //                        BLUELEDOFF();
233:                 //                        while( 0 == SW2INPUT );
234:                 //                        switch2Counter = 0;
235:                 //                        appData.state = APP_STATE_SLEEP;
236:                 //                        break;
237:                 //                    }
238:                 //                    
239:                 //                } else {
240:                 //                    switch2Counter = 0;
241:                 //                }
242:                 //            }
243:                             
244:                             GREENLEDON();
9D00054C  00002021   ADDU A0, ZERO, ZERO
9D000550  24050003   ADDIU A1, ZERO, 3
9D000554  00003021   ADDU A2, ZERO, ZERO
9D000558  0F400912   JAL SYS_PORTS_PinClear
9D00055C  00000000   NOP
245:                             
246:                             eink_startup();
9D000560  0F400A8C   JAL eink_startup
9D000564  00000000   NOP
247:                             eink_test_fill(BYTE_BLACK);
9D000568  24040055   ADDIU A0, ZERO, 85
9D00056C  0F4003D5   JAL eink_test_fill
9D000570  00000000   NOP
248:                             
249:                             appData.state = APP_STATE_SLEEP;
9D000574  AF808024   SW ZERO, -32732(GP)
250:                             
251:                             GREENLEDOFF();
9D000578  00002021   ADDU A0, ZERO, ZERO
9D00057C  24050003   ADDIU A1, ZERO, 3
9D000580  00003021   ADDU A2, ZERO, ZERO
9D000584  0F400900   JAL SYS_PORTS_PinSet
9D000588  00000000   NOP
252:                             
253:                             
254:                             break;
9D00058C  0B400176   J 0x9D0005D8
9D000590  00000000   NOP
255:                         }
256:                         case APP_STATE_CLEAR:
257:                         {
258:                             BLUELEDON();
9D000594  00002021   ADDU A0, ZERO, ZERO
9D000598  24050003   ADDIU A1, ZERO, 3
9D00059C  24060009   ADDIU A2, ZERO, 9
9D0005A0  0F400900   JAL SYS_PORTS_PinSet
9D0005A4  00000000   NOP
259:                             
260:                             eink_test_fill(BYTE_WHITE);
9D0005A8  240400AA   ADDIU A0, ZERO, 170
9D0005AC  0F4003D5   JAL eink_test_fill
9D0005B0  00000000   NOP
261:                             eink_shutdown();
9D0005B4  0F400A98   JAL eink_shutdown
9D0005B8  00000000   NOP
262:                             
263:                             appData.state = APP_STATE_SLEEP;
9D0005BC  AF808024   SW ZERO, -32732(GP)
264:                             
265:                             BLUELEDOFF();
9D0005C0  00002021   ADDU A0, ZERO, ZERO
9D0005C4  24050003   ADDIU A1, ZERO, 3
9D0005C8  24060009   ADDIU A2, ZERO, 9
9D0005CC  0F400912   JAL SYS_PORTS_PinClear
9D0005D0  00000000   NOP
266:                             
267:                             
268:                             break;
9D0005D4  00000000   NOP
269:                         }
270:                 
271:                         /* The default state should never be executed. */
272:                         default:
273:                         {
274:                             /* TODO: Handle error in application's state machine. */
275:                             break;
9D0003A8  0B400176   J 0x9D0005D8
9D0003AC  00000000   NOP
276:                         }
277:                     }
278:                 }
9D0005D8  03C0E821   ADDU SP, S8, ZERO
9D0005DC  8FBF001C   LW RA, 28(SP)
9D0005E0  8FBE0018   LW S8, 24(SP)
9D0005E4  27BD0020   ADDIU SP, SP, 32
9D0005E8  03E00008   JR RA
9D0005EC  00000000   NOP
279:                  
280:                 
281:                 /*******************************************************************************
282:                  End of File
283:                  */
---  /Volumes/home/c11067/xc32/build/xc32-XC32_v1_40_branch/src48x/gcc/libgcc/floatunsisf.c  ------------
00000000  00000000   NOP
00000008  00000000   NOP
00000024  00000000   NOP
00000010  00000000   NOP
00000018  00000000   NOP
00000040  00000000   NOP
